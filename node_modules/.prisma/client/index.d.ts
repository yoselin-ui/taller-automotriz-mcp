
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model clientes
 * 
 */
export type clientes = $Result.DefaultSelection<Prisma.$clientesPayload>
/**
 * Model vehiculos
 * 
 */
export type vehiculos = $Result.DefaultSelection<Prisma.$vehiculosPayload>
/**
 * Model servicios
 * 
 */
export type servicios = $Result.DefaultSelection<Prisma.$serviciosPayload>
/**
 * Model empleados
 * 
 */
export type empleados = $Result.DefaultSelection<Prisma.$empleadosPayload>
/**
 * Model ordenes_servicio
 * 
 */
export type ordenes_servicio = $Result.DefaultSelection<Prisma.$ordenes_servicioPayload>
/**
 * Model detalle_orden
 * 
 */
export type detalle_orden = $Result.DefaultSelection<Prisma.$detalle_ordenPayload>
/**
 * Model facturas
 * 
 */
export type facturas = $Result.DefaultSelection<Prisma.$facturasPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;

  /**
   * `prisma.clientes`: Exposes CRUD operations for the **clientes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientes
    * const clientes = await prisma.clientes.findMany()
    * ```
    */
  get clientes(): Prisma.clientesDelegate<ExtArgs>;

  /**
   * `prisma.vehiculos`: Exposes CRUD operations for the **vehiculos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehiculos
    * const vehiculos = await prisma.vehiculos.findMany()
    * ```
    */
  get vehiculos(): Prisma.vehiculosDelegate<ExtArgs>;

  /**
   * `prisma.servicios`: Exposes CRUD operations for the **servicios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicios
    * const servicios = await prisma.servicios.findMany()
    * ```
    */
  get servicios(): Prisma.serviciosDelegate<ExtArgs>;

  /**
   * `prisma.empleados`: Exposes CRUD operations for the **empleados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empleados
    * const empleados = await prisma.empleados.findMany()
    * ```
    */
  get empleados(): Prisma.empleadosDelegate<ExtArgs>;

  /**
   * `prisma.ordenes_servicio`: Exposes CRUD operations for the **ordenes_servicio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ordenes_servicios
    * const ordenes_servicios = await prisma.ordenes_servicio.findMany()
    * ```
    */
  get ordenes_servicio(): Prisma.ordenes_servicioDelegate<ExtArgs>;

  /**
   * `prisma.detalle_orden`: Exposes CRUD operations for the **detalle_orden** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Detalle_ordens
    * const detalle_ordens = await prisma.detalle_orden.findMany()
    * ```
    */
  get detalle_orden(): Prisma.detalle_ordenDelegate<ExtArgs>;

  /**
   * `prisma.facturas`: Exposes CRUD operations for the **facturas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Facturas
    * const facturas = await prisma.facturas.findMany()
    * ```
    */
  get facturas(): Prisma.facturasDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    users: 'users',
    clientes: 'clientes',
    vehiculos: 'vehiculos',
    servicios: 'servicios',
    empleados: 'empleados',
    ordenes_servicio: 'ordenes_servicio',
    detalle_orden: 'detalle_orden',
    facturas: 'facturas'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "users" | "clientes" | "vehiculos" | "servicios" | "empleados" | "ordenes_servicio" | "detalle_orden" | "facturas"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      clientes: {
        payload: Prisma.$clientesPayload<ExtArgs>
        fields: Prisma.clientesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clientesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clientesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientesPayload>
          }
          findFirst: {
            args: Prisma.clientesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clientesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientesPayload>
          }
          findMany: {
            args: Prisma.clientesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientesPayload>[]
          }
          create: {
            args: Prisma.clientesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientesPayload>
          }
          createMany: {
            args: Prisma.clientesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.clientesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientesPayload>[]
          }
          delete: {
            args: Prisma.clientesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientesPayload>
          }
          update: {
            args: Prisma.clientesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientesPayload>
          }
          deleteMany: {
            args: Prisma.clientesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clientesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.clientesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientesPayload>
          }
          aggregate: {
            args: Prisma.ClientesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientes>
          }
          groupBy: {
            args: Prisma.clientesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientesGroupByOutputType>[]
          }
          count: {
            args: Prisma.clientesCountArgs<ExtArgs>
            result: $Utils.Optional<ClientesCountAggregateOutputType> | number
          }
        }
      }
      vehiculos: {
        payload: Prisma.$vehiculosPayload<ExtArgs>
        fields: Prisma.vehiculosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vehiculosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiculosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vehiculosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiculosPayload>
          }
          findFirst: {
            args: Prisma.vehiculosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiculosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vehiculosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiculosPayload>
          }
          findMany: {
            args: Prisma.vehiculosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiculosPayload>[]
          }
          create: {
            args: Prisma.vehiculosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiculosPayload>
          }
          createMany: {
            args: Prisma.vehiculosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.vehiculosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiculosPayload>[]
          }
          delete: {
            args: Prisma.vehiculosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiculosPayload>
          }
          update: {
            args: Prisma.vehiculosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiculosPayload>
          }
          deleteMany: {
            args: Prisma.vehiculosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vehiculosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.vehiculosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiculosPayload>
          }
          aggregate: {
            args: Prisma.VehiculosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehiculos>
          }
          groupBy: {
            args: Prisma.vehiculosGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehiculosGroupByOutputType>[]
          }
          count: {
            args: Prisma.vehiculosCountArgs<ExtArgs>
            result: $Utils.Optional<VehiculosCountAggregateOutputType> | number
          }
        }
      }
      servicios: {
        payload: Prisma.$serviciosPayload<ExtArgs>
        fields: Prisma.serviciosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.serviciosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviciosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.serviciosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviciosPayload>
          }
          findFirst: {
            args: Prisma.serviciosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviciosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.serviciosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviciosPayload>
          }
          findMany: {
            args: Prisma.serviciosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviciosPayload>[]
          }
          create: {
            args: Prisma.serviciosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviciosPayload>
          }
          createMany: {
            args: Prisma.serviciosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.serviciosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviciosPayload>[]
          }
          delete: {
            args: Prisma.serviciosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviciosPayload>
          }
          update: {
            args: Prisma.serviciosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviciosPayload>
          }
          deleteMany: {
            args: Prisma.serviciosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.serviciosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.serviciosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviciosPayload>
          }
          aggregate: {
            args: Prisma.ServiciosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicios>
          }
          groupBy: {
            args: Prisma.serviciosGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiciosGroupByOutputType>[]
          }
          count: {
            args: Prisma.serviciosCountArgs<ExtArgs>
            result: $Utils.Optional<ServiciosCountAggregateOutputType> | number
          }
        }
      }
      empleados: {
        payload: Prisma.$empleadosPayload<ExtArgs>
        fields: Prisma.empleadosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.empleadosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empleadosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.empleadosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empleadosPayload>
          }
          findFirst: {
            args: Prisma.empleadosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empleadosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.empleadosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empleadosPayload>
          }
          findMany: {
            args: Prisma.empleadosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empleadosPayload>[]
          }
          create: {
            args: Prisma.empleadosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empleadosPayload>
          }
          createMany: {
            args: Prisma.empleadosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.empleadosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empleadosPayload>[]
          }
          delete: {
            args: Prisma.empleadosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empleadosPayload>
          }
          update: {
            args: Prisma.empleadosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empleadosPayload>
          }
          deleteMany: {
            args: Prisma.empleadosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.empleadosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.empleadosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empleadosPayload>
          }
          aggregate: {
            args: Prisma.EmpleadosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmpleados>
          }
          groupBy: {
            args: Prisma.empleadosGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmpleadosGroupByOutputType>[]
          }
          count: {
            args: Prisma.empleadosCountArgs<ExtArgs>
            result: $Utils.Optional<EmpleadosCountAggregateOutputType> | number
          }
        }
      }
      ordenes_servicio: {
        payload: Prisma.$ordenes_servicioPayload<ExtArgs>
        fields: Prisma.ordenes_servicioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ordenes_servicioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordenes_servicioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ordenes_servicioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordenes_servicioPayload>
          }
          findFirst: {
            args: Prisma.ordenes_servicioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordenes_servicioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ordenes_servicioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordenes_servicioPayload>
          }
          findMany: {
            args: Prisma.ordenes_servicioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordenes_servicioPayload>[]
          }
          create: {
            args: Prisma.ordenes_servicioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordenes_servicioPayload>
          }
          createMany: {
            args: Prisma.ordenes_servicioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ordenes_servicioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordenes_servicioPayload>[]
          }
          delete: {
            args: Prisma.ordenes_servicioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordenes_servicioPayload>
          }
          update: {
            args: Prisma.ordenes_servicioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordenes_servicioPayload>
          }
          deleteMany: {
            args: Prisma.ordenes_servicioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ordenes_servicioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ordenes_servicioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordenes_servicioPayload>
          }
          aggregate: {
            args: Prisma.Ordenes_servicioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrdenes_servicio>
          }
          groupBy: {
            args: Prisma.ordenes_servicioGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ordenes_servicioGroupByOutputType>[]
          }
          count: {
            args: Prisma.ordenes_servicioCountArgs<ExtArgs>
            result: $Utils.Optional<Ordenes_servicioCountAggregateOutputType> | number
          }
        }
      }
      detalle_orden: {
        payload: Prisma.$detalle_ordenPayload<ExtArgs>
        fields: Prisma.detalle_ordenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.detalle_ordenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_ordenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.detalle_ordenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_ordenPayload>
          }
          findFirst: {
            args: Prisma.detalle_ordenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_ordenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.detalle_ordenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_ordenPayload>
          }
          findMany: {
            args: Prisma.detalle_ordenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_ordenPayload>[]
          }
          create: {
            args: Prisma.detalle_ordenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_ordenPayload>
          }
          createMany: {
            args: Prisma.detalle_ordenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.detalle_ordenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_ordenPayload>[]
          }
          delete: {
            args: Prisma.detalle_ordenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_ordenPayload>
          }
          update: {
            args: Prisma.detalle_ordenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_ordenPayload>
          }
          deleteMany: {
            args: Prisma.detalle_ordenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.detalle_ordenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.detalle_ordenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_ordenPayload>
          }
          aggregate: {
            args: Prisma.Detalle_ordenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDetalle_orden>
          }
          groupBy: {
            args: Prisma.detalle_ordenGroupByArgs<ExtArgs>
            result: $Utils.Optional<Detalle_ordenGroupByOutputType>[]
          }
          count: {
            args: Prisma.detalle_ordenCountArgs<ExtArgs>
            result: $Utils.Optional<Detalle_ordenCountAggregateOutputType> | number
          }
        }
      }
      facturas: {
        payload: Prisma.$facturasPayload<ExtArgs>
        fields: Prisma.facturasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.facturasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.facturasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturasPayload>
          }
          findFirst: {
            args: Prisma.facturasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.facturasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturasPayload>
          }
          findMany: {
            args: Prisma.facturasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturasPayload>[]
          }
          create: {
            args: Prisma.facturasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturasPayload>
          }
          createMany: {
            args: Prisma.facturasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.facturasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturasPayload>[]
          }
          delete: {
            args: Prisma.facturasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturasPayload>
          }
          update: {
            args: Prisma.facturasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturasPayload>
          }
          deleteMany: {
            args: Prisma.facturasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.facturasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.facturasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturasPayload>
          }
          aggregate: {
            args: Prisma.FacturasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacturas>
          }
          groupBy: {
            args: Prisma.facturasGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacturasGroupByOutputType>[]
          }
          count: {
            args: Prisma.facturasCountArgs<ExtArgs>
            result: $Utils.Optional<FacturasCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClientesCountOutputType
   */

  export type ClientesCountOutputType = {
    vehiculos: number
  }

  export type ClientesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehiculos?: boolean | ClientesCountOutputTypeCountVehiculosArgs
  }

  // Custom InputTypes
  /**
   * ClientesCountOutputType without action
   */
  export type ClientesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientesCountOutputType
     */
    select?: ClientesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientesCountOutputType without action
   */
  export type ClientesCountOutputTypeCountVehiculosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehiculosWhereInput
  }


  /**
   * Count Type VehiculosCountOutputType
   */

  export type VehiculosCountOutputType = {
    ordenes_servicio: number
  }

  export type VehiculosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ordenes_servicio?: boolean | VehiculosCountOutputTypeCountOrdenes_servicioArgs
  }

  // Custom InputTypes
  /**
   * VehiculosCountOutputType without action
   */
  export type VehiculosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehiculosCountOutputType
     */
    select?: VehiculosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehiculosCountOutputType without action
   */
  export type VehiculosCountOutputTypeCountOrdenes_servicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordenes_servicioWhereInput
  }


  /**
   * Count Type ServiciosCountOutputType
   */

  export type ServiciosCountOutputType = {
    detalle_orden: number
  }

  export type ServiciosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detalle_orden?: boolean | ServiciosCountOutputTypeCountDetalle_ordenArgs
  }

  // Custom InputTypes
  /**
   * ServiciosCountOutputType without action
   */
  export type ServiciosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiciosCountOutputType
     */
    select?: ServiciosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiciosCountOutputType without action
   */
  export type ServiciosCountOutputTypeCountDetalle_ordenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detalle_ordenWhereInput
  }


  /**
   * Count Type EmpleadosCountOutputType
   */

  export type EmpleadosCountOutputType = {
    ordenes_servicio: number
  }

  export type EmpleadosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ordenes_servicio?: boolean | EmpleadosCountOutputTypeCountOrdenes_servicioArgs
  }

  // Custom InputTypes
  /**
   * EmpleadosCountOutputType without action
   */
  export type EmpleadosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpleadosCountOutputType
     */
    select?: EmpleadosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmpleadosCountOutputType without action
   */
  export type EmpleadosCountOutputTypeCountOrdenes_servicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordenes_servicioWhereInput
  }


  /**
   * Count Type Ordenes_servicioCountOutputType
   */

  export type Ordenes_servicioCountOutputType = {
    detalle_orden: number
    facturas: number
  }

  export type Ordenes_servicioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detalle_orden?: boolean | Ordenes_servicioCountOutputTypeCountDetalle_ordenArgs
    facturas?: boolean | Ordenes_servicioCountOutputTypeCountFacturasArgs
  }

  // Custom InputTypes
  /**
   * Ordenes_servicioCountOutputType without action
   */
  export type Ordenes_servicioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ordenes_servicioCountOutputType
     */
    select?: Ordenes_servicioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Ordenes_servicioCountOutputType without action
   */
  export type Ordenes_servicioCountOutputTypeCountDetalle_ordenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detalle_ordenWhereInput
  }

  /**
   * Ordenes_servicioCountOutputType without action
   */
  export type Ordenes_servicioCountOutputTypeCountFacturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: facturasWhereInput
  }


  /**
   * Models
   */

  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    nombre: string | null
    rol: string | null
    activo: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    nombre: string | null
    rol: string | null
    activo: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    email: number
    password: number
    nombre: number
    rol: number
    activo: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    nombre?: true
    rol?: true
    activo?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    nombre?: true
    rol?: true
    activo?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    nombre?: true
    rol?: true
    activo?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    email: string
    password: string
    nombre: string
    rol: string
    activo: boolean
    created_at: Date | null
    updated_at: Date | null
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    nombre?: boolean
    rol?: boolean
    activo?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    nombre?: boolean
    rol?: boolean
    activo?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    nombre?: boolean
    rol?: boolean
    activo?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      nombre: string
      rol: string
      activo: boolean
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly nombre: FieldRef<"users", 'String'>
    readonly rol: FieldRef<"users", 'String'>
    readonly activo: FieldRef<"users", 'Boolean'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
  }


  /**
   * Model clientes
   */

  export type AggregateClientes = {
    _count: ClientesCountAggregateOutputType | null
    _avg: ClientesAvgAggregateOutputType | null
    _sum: ClientesSumAggregateOutputType | null
    _min: ClientesMinAggregateOutputType | null
    _max: ClientesMaxAggregateOutputType | null
  }

  export type ClientesAvgAggregateOutputType = {
    id_cliente: number | null
  }

  export type ClientesSumAggregateOutputType = {
    id_cliente: number | null
  }

  export type ClientesMinAggregateOutputType = {
    id_cliente: number | null
    nombre: string | null
    direccion: string | null
    telefono: string | null
    correo: string | null
    created_at: Date | null
  }

  export type ClientesMaxAggregateOutputType = {
    id_cliente: number | null
    nombre: string | null
    direccion: string | null
    telefono: string | null
    correo: string | null
    created_at: Date | null
  }

  export type ClientesCountAggregateOutputType = {
    id_cliente: number
    nombre: number
    direccion: number
    telefono: number
    correo: number
    created_at: number
    _all: number
  }


  export type ClientesAvgAggregateInputType = {
    id_cliente?: true
  }

  export type ClientesSumAggregateInputType = {
    id_cliente?: true
  }

  export type ClientesMinAggregateInputType = {
    id_cliente?: true
    nombre?: true
    direccion?: true
    telefono?: true
    correo?: true
    created_at?: true
  }

  export type ClientesMaxAggregateInputType = {
    id_cliente?: true
    nombre?: true
    direccion?: true
    telefono?: true
    correo?: true
    created_at?: true
  }

  export type ClientesCountAggregateInputType = {
    id_cliente?: true
    nombre?: true
    direccion?: true
    telefono?: true
    correo?: true
    created_at?: true
    _all?: true
  }

  export type ClientesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clientes to aggregate.
     */
    where?: clientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     */
    orderBy?: clientesOrderByWithRelationInput | clientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clientes
    **/
    _count?: true | ClientesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientesMaxAggregateInputType
  }

  export type GetClientesAggregateType<T extends ClientesAggregateArgs> = {
        [P in keyof T & keyof AggregateClientes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientes[P]>
      : GetScalarType<T[P], AggregateClientes[P]>
  }




  export type clientesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clientesWhereInput
    orderBy?: clientesOrderByWithAggregationInput | clientesOrderByWithAggregationInput[]
    by: ClientesScalarFieldEnum[] | ClientesScalarFieldEnum
    having?: clientesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientesCountAggregateInputType | true
    _avg?: ClientesAvgAggregateInputType
    _sum?: ClientesSumAggregateInputType
    _min?: ClientesMinAggregateInputType
    _max?: ClientesMaxAggregateInputType
  }

  export type ClientesGroupByOutputType = {
    id_cliente: number
    nombre: string
    direccion: string | null
    telefono: string
    correo: string | null
    created_at: Date | null
    _count: ClientesCountAggregateOutputType | null
    _avg: ClientesAvgAggregateOutputType | null
    _sum: ClientesSumAggregateOutputType | null
    _min: ClientesMinAggregateOutputType | null
    _max: ClientesMaxAggregateOutputType | null
  }

  type GetClientesGroupByPayload<T extends clientesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientesGroupByOutputType[P]>
            : GetScalarType<T[P], ClientesGroupByOutputType[P]>
        }
      >
    >


  export type clientesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_cliente?: boolean
    nombre?: boolean
    direccion?: boolean
    telefono?: boolean
    correo?: boolean
    created_at?: boolean
    vehiculos?: boolean | clientes$vehiculosArgs<ExtArgs>
    _count?: boolean | ClientesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientes"]>

  export type clientesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_cliente?: boolean
    nombre?: boolean
    direccion?: boolean
    telefono?: boolean
    correo?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["clientes"]>

  export type clientesSelectScalar = {
    id_cliente?: boolean
    nombre?: boolean
    direccion?: boolean
    telefono?: boolean
    correo?: boolean
    created_at?: boolean
  }

  export type clientesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehiculos?: boolean | clientes$vehiculosArgs<ExtArgs>
    _count?: boolean | ClientesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type clientesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $clientesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clientes"
    objects: {
      vehiculos: Prisma.$vehiculosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_cliente: number
      nombre: string
      direccion: string | null
      telefono: string
      correo: string | null
      created_at: Date | null
    }, ExtArgs["result"]["clientes"]>
    composites: {}
  }

  type clientesGetPayload<S extends boolean | null | undefined | clientesDefaultArgs> = $Result.GetResult<Prisma.$clientesPayload, S>

  type clientesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<clientesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientesCountAggregateInputType | true
    }

  export interface clientesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clientes'], meta: { name: 'clientes' } }
    /**
     * Find zero or one Clientes that matches the filter.
     * @param {clientesFindUniqueArgs} args - Arguments to find a Clientes
     * @example
     * // Get one Clientes
     * const clientes = await prisma.clientes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clientesFindUniqueArgs>(args: SelectSubset<T, clientesFindUniqueArgs<ExtArgs>>): Prisma__clientesClient<$Result.GetResult<Prisma.$clientesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Clientes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {clientesFindUniqueOrThrowArgs} args - Arguments to find a Clientes
     * @example
     * // Get one Clientes
     * const clientes = await prisma.clientes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clientesFindUniqueOrThrowArgs>(args: SelectSubset<T, clientesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clientesClient<$Result.GetResult<Prisma.$clientesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientesFindFirstArgs} args - Arguments to find a Clientes
     * @example
     * // Get one Clientes
     * const clientes = await prisma.clientes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clientesFindFirstArgs>(args?: SelectSubset<T, clientesFindFirstArgs<ExtArgs>>): Prisma__clientesClient<$Result.GetResult<Prisma.$clientesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Clientes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientesFindFirstOrThrowArgs} args - Arguments to find a Clientes
     * @example
     * // Get one Clientes
     * const clientes = await prisma.clientes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clientesFindFirstOrThrowArgs>(args?: SelectSubset<T, clientesFindFirstOrThrowArgs<ExtArgs>>): Prisma__clientesClient<$Result.GetResult<Prisma.$clientesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.clientes.findMany()
     * 
     * // Get first 10 Clientes
     * const clientes = await prisma.clientes.findMany({ take: 10 })
     * 
     * // Only select the `id_cliente`
     * const clientesWithId_clienteOnly = await prisma.clientes.findMany({ select: { id_cliente: true } })
     * 
     */
    findMany<T extends clientesFindManyArgs>(args?: SelectSubset<T, clientesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Clientes.
     * @param {clientesCreateArgs} args - Arguments to create a Clientes.
     * @example
     * // Create one Clientes
     * const Clientes = await prisma.clientes.create({
     *   data: {
     *     // ... data to create a Clientes
     *   }
     * })
     * 
     */
    create<T extends clientesCreateArgs>(args: SelectSubset<T, clientesCreateArgs<ExtArgs>>): Prisma__clientesClient<$Result.GetResult<Prisma.$clientesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clientes.
     * @param {clientesCreateManyArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const clientes = await prisma.clientes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clientesCreateManyArgs>(args?: SelectSubset<T, clientesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clientes and returns the data saved in the database.
     * @param {clientesCreateManyAndReturnArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const clientes = await prisma.clientes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clientes and only return the `id_cliente`
     * const clientesWithId_clienteOnly = await prisma.clientes.createManyAndReturn({ 
     *   select: { id_cliente: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends clientesCreateManyAndReturnArgs>(args?: SelectSubset<T, clientesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Clientes.
     * @param {clientesDeleteArgs} args - Arguments to delete one Clientes.
     * @example
     * // Delete one Clientes
     * const Clientes = await prisma.clientes.delete({
     *   where: {
     *     // ... filter to delete one Clientes
     *   }
     * })
     * 
     */
    delete<T extends clientesDeleteArgs>(args: SelectSubset<T, clientesDeleteArgs<ExtArgs>>): Prisma__clientesClient<$Result.GetResult<Prisma.$clientesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Clientes.
     * @param {clientesUpdateArgs} args - Arguments to update one Clientes.
     * @example
     * // Update one Clientes
     * const clientes = await prisma.clientes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clientesUpdateArgs>(args: SelectSubset<T, clientesUpdateArgs<ExtArgs>>): Prisma__clientesClient<$Result.GetResult<Prisma.$clientesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clientes.
     * @param {clientesDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.clientes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clientesDeleteManyArgs>(args?: SelectSubset<T, clientesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const clientes = await prisma.clientes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clientesUpdateManyArgs>(args: SelectSubset<T, clientesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Clientes.
     * @param {clientesUpsertArgs} args - Arguments to update or create a Clientes.
     * @example
     * // Update or create a Clientes
     * const clientes = await prisma.clientes.upsert({
     *   create: {
     *     // ... data to create a Clientes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clientes we want to update
     *   }
     * })
     */
    upsert<T extends clientesUpsertArgs>(args: SelectSubset<T, clientesUpsertArgs<ExtArgs>>): Prisma__clientesClient<$Result.GetResult<Prisma.$clientesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientesCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.clientes.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
    **/
    count<T extends clientesCountArgs>(
      args?: Subset<T, clientesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientesAggregateArgs>(args: Subset<T, ClientesAggregateArgs>): Prisma.PrismaPromise<GetClientesAggregateType<T>>

    /**
     * Group by Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clientesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clientesGroupByArgs['orderBy'] }
        : { orderBy?: clientesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clientesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clientes model
   */
  readonly fields: clientesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clientes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clientesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehiculos<T extends clientes$vehiculosArgs<ExtArgs> = {}>(args?: Subset<T, clientes$vehiculosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehiculosPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clientes model
   */ 
  interface clientesFieldRefs {
    readonly id_cliente: FieldRef<"clientes", 'Int'>
    readonly nombre: FieldRef<"clientes", 'String'>
    readonly direccion: FieldRef<"clientes", 'String'>
    readonly telefono: FieldRef<"clientes", 'String'>
    readonly correo: FieldRef<"clientes", 'String'>
    readonly created_at: FieldRef<"clientes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * clientes findUnique
   */
  export type clientesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientes
     */
    select?: clientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientesInclude<ExtArgs> | null
    /**
     * Filter, which clientes to fetch.
     */
    where: clientesWhereUniqueInput
  }

  /**
   * clientes findUniqueOrThrow
   */
  export type clientesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientes
     */
    select?: clientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientesInclude<ExtArgs> | null
    /**
     * Filter, which clientes to fetch.
     */
    where: clientesWhereUniqueInput
  }

  /**
   * clientes findFirst
   */
  export type clientesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientes
     */
    select?: clientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientesInclude<ExtArgs> | null
    /**
     * Filter, which clientes to fetch.
     */
    where?: clientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     */
    orderBy?: clientesOrderByWithRelationInput | clientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientes.
     */
    cursor?: clientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientes.
     */
    distinct?: ClientesScalarFieldEnum | ClientesScalarFieldEnum[]
  }

  /**
   * clientes findFirstOrThrow
   */
  export type clientesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientes
     */
    select?: clientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientesInclude<ExtArgs> | null
    /**
     * Filter, which clientes to fetch.
     */
    where?: clientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     */
    orderBy?: clientesOrderByWithRelationInput | clientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientes.
     */
    cursor?: clientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientes.
     */
    distinct?: ClientesScalarFieldEnum | ClientesScalarFieldEnum[]
  }

  /**
   * clientes findMany
   */
  export type clientesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientes
     */
    select?: clientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientesInclude<ExtArgs> | null
    /**
     * Filter, which clientes to fetch.
     */
    where?: clientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     */
    orderBy?: clientesOrderByWithRelationInput | clientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clientes.
     */
    cursor?: clientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     */
    skip?: number
    distinct?: ClientesScalarFieldEnum | ClientesScalarFieldEnum[]
  }

  /**
   * clientes create
   */
  export type clientesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientes
     */
    select?: clientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientesInclude<ExtArgs> | null
    /**
     * The data needed to create a clientes.
     */
    data: XOR<clientesCreateInput, clientesUncheckedCreateInput>
  }

  /**
   * clientes createMany
   */
  export type clientesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clientes.
     */
    data: clientesCreateManyInput | clientesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clientes createManyAndReturn
   */
  export type clientesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientes
     */
    select?: clientesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many clientes.
     */
    data: clientesCreateManyInput | clientesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clientes update
   */
  export type clientesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientes
     */
    select?: clientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientesInclude<ExtArgs> | null
    /**
     * The data needed to update a clientes.
     */
    data: XOR<clientesUpdateInput, clientesUncheckedUpdateInput>
    /**
     * Choose, which clientes to update.
     */
    where: clientesWhereUniqueInput
  }

  /**
   * clientes updateMany
   */
  export type clientesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clientes.
     */
    data: XOR<clientesUpdateManyMutationInput, clientesUncheckedUpdateManyInput>
    /**
     * Filter which clientes to update
     */
    where?: clientesWhereInput
  }

  /**
   * clientes upsert
   */
  export type clientesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientes
     */
    select?: clientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientesInclude<ExtArgs> | null
    /**
     * The filter to search for the clientes to update in case it exists.
     */
    where: clientesWhereUniqueInput
    /**
     * In case the clientes found by the `where` argument doesn't exist, create a new clientes with this data.
     */
    create: XOR<clientesCreateInput, clientesUncheckedCreateInput>
    /**
     * In case the clientes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clientesUpdateInput, clientesUncheckedUpdateInput>
  }

  /**
   * clientes delete
   */
  export type clientesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientes
     */
    select?: clientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientesInclude<ExtArgs> | null
    /**
     * Filter which clientes to delete.
     */
    where: clientesWhereUniqueInput
  }

  /**
   * clientes deleteMany
   */
  export type clientesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clientes to delete
     */
    where?: clientesWhereInput
  }

  /**
   * clientes.vehiculos
   */
  export type clientes$vehiculosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehiculos
     */
    select?: vehiculosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiculosInclude<ExtArgs> | null
    where?: vehiculosWhereInput
    orderBy?: vehiculosOrderByWithRelationInput | vehiculosOrderByWithRelationInput[]
    cursor?: vehiculosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehiculosScalarFieldEnum | VehiculosScalarFieldEnum[]
  }

  /**
   * clientes without action
   */
  export type clientesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientes
     */
    select?: clientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientesInclude<ExtArgs> | null
  }


  /**
   * Model vehiculos
   */

  export type AggregateVehiculos = {
    _count: VehiculosCountAggregateOutputType | null
    _avg: VehiculosAvgAggregateOutputType | null
    _sum: VehiculosSumAggregateOutputType | null
    _min: VehiculosMinAggregateOutputType | null
    _max: VehiculosMaxAggregateOutputType | null
  }

  export type VehiculosAvgAggregateOutputType = {
    id_vehiculo: number | null
    id_cliente: number | null
    anio: number | null
  }

  export type VehiculosSumAggregateOutputType = {
    id_vehiculo: number | null
    id_cliente: number | null
    anio: number | null
  }

  export type VehiculosMinAggregateOutputType = {
    id_vehiculo: number | null
    id_cliente: number | null
    marca: string | null
    modelo: string | null
    anio: number | null
    placas: string | null
    color: string | null
    vin: string | null
    created_at: Date | null
  }

  export type VehiculosMaxAggregateOutputType = {
    id_vehiculo: number | null
    id_cliente: number | null
    marca: string | null
    modelo: string | null
    anio: number | null
    placas: string | null
    color: string | null
    vin: string | null
    created_at: Date | null
  }

  export type VehiculosCountAggregateOutputType = {
    id_vehiculo: number
    id_cliente: number
    marca: number
    modelo: number
    anio: number
    placas: number
    color: number
    vin: number
    created_at: number
    _all: number
  }


  export type VehiculosAvgAggregateInputType = {
    id_vehiculo?: true
    id_cliente?: true
    anio?: true
  }

  export type VehiculosSumAggregateInputType = {
    id_vehiculo?: true
    id_cliente?: true
    anio?: true
  }

  export type VehiculosMinAggregateInputType = {
    id_vehiculo?: true
    id_cliente?: true
    marca?: true
    modelo?: true
    anio?: true
    placas?: true
    color?: true
    vin?: true
    created_at?: true
  }

  export type VehiculosMaxAggregateInputType = {
    id_vehiculo?: true
    id_cliente?: true
    marca?: true
    modelo?: true
    anio?: true
    placas?: true
    color?: true
    vin?: true
    created_at?: true
  }

  export type VehiculosCountAggregateInputType = {
    id_vehiculo?: true
    id_cliente?: true
    marca?: true
    modelo?: true
    anio?: true
    placas?: true
    color?: true
    vin?: true
    created_at?: true
    _all?: true
  }

  export type VehiculosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehiculos to aggregate.
     */
    where?: vehiculosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehiculos to fetch.
     */
    orderBy?: vehiculosOrderByWithRelationInput | vehiculosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vehiculosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehiculos
    **/
    _count?: true | VehiculosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehiculosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehiculosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehiculosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehiculosMaxAggregateInputType
  }

  export type GetVehiculosAggregateType<T extends VehiculosAggregateArgs> = {
        [P in keyof T & keyof AggregateVehiculos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehiculos[P]>
      : GetScalarType<T[P], AggregateVehiculos[P]>
  }




  export type vehiculosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehiculosWhereInput
    orderBy?: vehiculosOrderByWithAggregationInput | vehiculosOrderByWithAggregationInput[]
    by: VehiculosScalarFieldEnum[] | VehiculosScalarFieldEnum
    having?: vehiculosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehiculosCountAggregateInputType | true
    _avg?: VehiculosAvgAggregateInputType
    _sum?: VehiculosSumAggregateInputType
    _min?: VehiculosMinAggregateInputType
    _max?: VehiculosMaxAggregateInputType
  }

  export type VehiculosGroupByOutputType = {
    id_vehiculo: number
    id_cliente: number
    marca: string
    modelo: string
    anio: number
    placas: string
    color: string | null
    vin: string | null
    created_at: Date | null
    _count: VehiculosCountAggregateOutputType | null
    _avg: VehiculosAvgAggregateOutputType | null
    _sum: VehiculosSumAggregateOutputType | null
    _min: VehiculosMinAggregateOutputType | null
    _max: VehiculosMaxAggregateOutputType | null
  }

  type GetVehiculosGroupByPayload<T extends vehiculosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehiculosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehiculosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehiculosGroupByOutputType[P]>
            : GetScalarType<T[P], VehiculosGroupByOutputType[P]>
        }
      >
    >


  export type vehiculosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_vehiculo?: boolean
    id_cliente?: boolean
    marca?: boolean
    modelo?: boolean
    anio?: boolean
    placas?: boolean
    color?: boolean
    vin?: boolean
    created_at?: boolean
    cliente?: boolean | clientesDefaultArgs<ExtArgs>
    ordenes_servicio?: boolean | vehiculos$ordenes_servicioArgs<ExtArgs>
    _count?: boolean | VehiculosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehiculos"]>

  export type vehiculosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_vehiculo?: boolean
    id_cliente?: boolean
    marca?: boolean
    modelo?: boolean
    anio?: boolean
    placas?: boolean
    color?: boolean
    vin?: boolean
    created_at?: boolean
    cliente?: boolean | clientesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehiculos"]>

  export type vehiculosSelectScalar = {
    id_vehiculo?: boolean
    id_cliente?: boolean
    marca?: boolean
    modelo?: boolean
    anio?: boolean
    placas?: boolean
    color?: boolean
    vin?: boolean
    created_at?: boolean
  }

  export type vehiculosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | clientesDefaultArgs<ExtArgs>
    ordenes_servicio?: boolean | vehiculos$ordenes_servicioArgs<ExtArgs>
    _count?: boolean | VehiculosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type vehiculosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | clientesDefaultArgs<ExtArgs>
  }

  export type $vehiculosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vehiculos"
    objects: {
      cliente: Prisma.$clientesPayload<ExtArgs>
      ordenes_servicio: Prisma.$ordenes_servicioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_vehiculo: number
      id_cliente: number
      marca: string
      modelo: string
      anio: number
      placas: string
      color: string | null
      vin: string | null
      created_at: Date | null
    }, ExtArgs["result"]["vehiculos"]>
    composites: {}
  }

  type vehiculosGetPayload<S extends boolean | null | undefined | vehiculosDefaultArgs> = $Result.GetResult<Prisma.$vehiculosPayload, S>

  type vehiculosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<vehiculosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VehiculosCountAggregateInputType | true
    }

  export interface vehiculosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vehiculos'], meta: { name: 'vehiculos' } }
    /**
     * Find zero or one Vehiculos that matches the filter.
     * @param {vehiculosFindUniqueArgs} args - Arguments to find a Vehiculos
     * @example
     * // Get one Vehiculos
     * const vehiculos = await prisma.vehiculos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vehiculosFindUniqueArgs>(args: SelectSubset<T, vehiculosFindUniqueArgs<ExtArgs>>): Prisma__vehiculosClient<$Result.GetResult<Prisma.$vehiculosPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Vehiculos that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {vehiculosFindUniqueOrThrowArgs} args - Arguments to find a Vehiculos
     * @example
     * // Get one Vehiculos
     * const vehiculos = await prisma.vehiculos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vehiculosFindUniqueOrThrowArgs>(args: SelectSubset<T, vehiculosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vehiculosClient<$Result.GetResult<Prisma.$vehiculosPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Vehiculos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiculosFindFirstArgs} args - Arguments to find a Vehiculos
     * @example
     * // Get one Vehiculos
     * const vehiculos = await prisma.vehiculos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vehiculosFindFirstArgs>(args?: SelectSubset<T, vehiculosFindFirstArgs<ExtArgs>>): Prisma__vehiculosClient<$Result.GetResult<Prisma.$vehiculosPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Vehiculos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiculosFindFirstOrThrowArgs} args - Arguments to find a Vehiculos
     * @example
     * // Get one Vehiculos
     * const vehiculos = await prisma.vehiculos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vehiculosFindFirstOrThrowArgs>(args?: SelectSubset<T, vehiculosFindFirstOrThrowArgs<ExtArgs>>): Prisma__vehiculosClient<$Result.GetResult<Prisma.$vehiculosPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Vehiculos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiculosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehiculos
     * const vehiculos = await prisma.vehiculos.findMany()
     * 
     * // Get first 10 Vehiculos
     * const vehiculos = await prisma.vehiculos.findMany({ take: 10 })
     * 
     * // Only select the `id_vehiculo`
     * const vehiculosWithId_vehiculoOnly = await prisma.vehiculos.findMany({ select: { id_vehiculo: true } })
     * 
     */
    findMany<T extends vehiculosFindManyArgs>(args?: SelectSubset<T, vehiculosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehiculosPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Vehiculos.
     * @param {vehiculosCreateArgs} args - Arguments to create a Vehiculos.
     * @example
     * // Create one Vehiculos
     * const Vehiculos = await prisma.vehiculos.create({
     *   data: {
     *     // ... data to create a Vehiculos
     *   }
     * })
     * 
     */
    create<T extends vehiculosCreateArgs>(args: SelectSubset<T, vehiculosCreateArgs<ExtArgs>>): Prisma__vehiculosClient<$Result.GetResult<Prisma.$vehiculosPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Vehiculos.
     * @param {vehiculosCreateManyArgs} args - Arguments to create many Vehiculos.
     * @example
     * // Create many Vehiculos
     * const vehiculos = await prisma.vehiculos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vehiculosCreateManyArgs>(args?: SelectSubset<T, vehiculosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehiculos and returns the data saved in the database.
     * @param {vehiculosCreateManyAndReturnArgs} args - Arguments to create many Vehiculos.
     * @example
     * // Create many Vehiculos
     * const vehiculos = await prisma.vehiculos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehiculos and only return the `id_vehiculo`
     * const vehiculosWithId_vehiculoOnly = await prisma.vehiculos.createManyAndReturn({ 
     *   select: { id_vehiculo: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends vehiculosCreateManyAndReturnArgs>(args?: SelectSubset<T, vehiculosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehiculosPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Vehiculos.
     * @param {vehiculosDeleteArgs} args - Arguments to delete one Vehiculos.
     * @example
     * // Delete one Vehiculos
     * const Vehiculos = await prisma.vehiculos.delete({
     *   where: {
     *     // ... filter to delete one Vehiculos
     *   }
     * })
     * 
     */
    delete<T extends vehiculosDeleteArgs>(args: SelectSubset<T, vehiculosDeleteArgs<ExtArgs>>): Prisma__vehiculosClient<$Result.GetResult<Prisma.$vehiculosPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Vehiculos.
     * @param {vehiculosUpdateArgs} args - Arguments to update one Vehiculos.
     * @example
     * // Update one Vehiculos
     * const vehiculos = await prisma.vehiculos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vehiculosUpdateArgs>(args: SelectSubset<T, vehiculosUpdateArgs<ExtArgs>>): Prisma__vehiculosClient<$Result.GetResult<Prisma.$vehiculosPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Vehiculos.
     * @param {vehiculosDeleteManyArgs} args - Arguments to filter Vehiculos to delete.
     * @example
     * // Delete a few Vehiculos
     * const { count } = await prisma.vehiculos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vehiculosDeleteManyArgs>(args?: SelectSubset<T, vehiculosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiculosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehiculos
     * const vehiculos = await prisma.vehiculos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vehiculosUpdateManyArgs>(args: SelectSubset<T, vehiculosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehiculos.
     * @param {vehiculosUpsertArgs} args - Arguments to update or create a Vehiculos.
     * @example
     * // Update or create a Vehiculos
     * const vehiculos = await prisma.vehiculos.upsert({
     *   create: {
     *     // ... data to create a Vehiculos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehiculos we want to update
     *   }
     * })
     */
    upsert<T extends vehiculosUpsertArgs>(args: SelectSubset<T, vehiculosUpsertArgs<ExtArgs>>): Prisma__vehiculosClient<$Result.GetResult<Prisma.$vehiculosPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Vehiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiculosCountArgs} args - Arguments to filter Vehiculos to count.
     * @example
     * // Count the number of Vehiculos
     * const count = await prisma.vehiculos.count({
     *   where: {
     *     // ... the filter for the Vehiculos we want to count
     *   }
     * })
    **/
    count<T extends vehiculosCountArgs>(
      args?: Subset<T, vehiculosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehiculosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiculosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehiculosAggregateArgs>(args: Subset<T, VehiculosAggregateArgs>): Prisma.PrismaPromise<GetVehiculosAggregateType<T>>

    /**
     * Group by Vehiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiculosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vehiculosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vehiculosGroupByArgs['orderBy'] }
        : { orderBy?: vehiculosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vehiculosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehiculosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vehiculos model
   */
  readonly fields: vehiculosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vehiculos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vehiculosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cliente<T extends clientesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clientesDefaultArgs<ExtArgs>>): Prisma__clientesClient<$Result.GetResult<Prisma.$clientesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ordenes_servicio<T extends vehiculos$ordenes_servicioArgs<ExtArgs> = {}>(args?: Subset<T, vehiculos$ordenes_servicioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordenes_servicioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vehiculos model
   */ 
  interface vehiculosFieldRefs {
    readonly id_vehiculo: FieldRef<"vehiculos", 'Int'>
    readonly id_cliente: FieldRef<"vehiculos", 'Int'>
    readonly marca: FieldRef<"vehiculos", 'String'>
    readonly modelo: FieldRef<"vehiculos", 'String'>
    readonly anio: FieldRef<"vehiculos", 'Int'>
    readonly placas: FieldRef<"vehiculos", 'String'>
    readonly color: FieldRef<"vehiculos", 'String'>
    readonly vin: FieldRef<"vehiculos", 'String'>
    readonly created_at: FieldRef<"vehiculos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * vehiculos findUnique
   */
  export type vehiculosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehiculos
     */
    select?: vehiculosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiculosInclude<ExtArgs> | null
    /**
     * Filter, which vehiculos to fetch.
     */
    where: vehiculosWhereUniqueInput
  }

  /**
   * vehiculos findUniqueOrThrow
   */
  export type vehiculosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehiculos
     */
    select?: vehiculosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiculosInclude<ExtArgs> | null
    /**
     * Filter, which vehiculos to fetch.
     */
    where: vehiculosWhereUniqueInput
  }

  /**
   * vehiculos findFirst
   */
  export type vehiculosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehiculos
     */
    select?: vehiculosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiculosInclude<ExtArgs> | null
    /**
     * Filter, which vehiculos to fetch.
     */
    where?: vehiculosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehiculos to fetch.
     */
    orderBy?: vehiculosOrderByWithRelationInput | vehiculosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehiculos.
     */
    cursor?: vehiculosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehiculos.
     */
    distinct?: VehiculosScalarFieldEnum | VehiculosScalarFieldEnum[]
  }

  /**
   * vehiculos findFirstOrThrow
   */
  export type vehiculosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehiculos
     */
    select?: vehiculosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiculosInclude<ExtArgs> | null
    /**
     * Filter, which vehiculos to fetch.
     */
    where?: vehiculosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehiculos to fetch.
     */
    orderBy?: vehiculosOrderByWithRelationInput | vehiculosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehiculos.
     */
    cursor?: vehiculosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehiculos.
     */
    distinct?: VehiculosScalarFieldEnum | VehiculosScalarFieldEnum[]
  }

  /**
   * vehiculos findMany
   */
  export type vehiculosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehiculos
     */
    select?: vehiculosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiculosInclude<ExtArgs> | null
    /**
     * Filter, which vehiculos to fetch.
     */
    where?: vehiculosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehiculos to fetch.
     */
    orderBy?: vehiculosOrderByWithRelationInput | vehiculosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehiculos.
     */
    cursor?: vehiculosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehiculos.
     */
    skip?: number
    distinct?: VehiculosScalarFieldEnum | VehiculosScalarFieldEnum[]
  }

  /**
   * vehiculos create
   */
  export type vehiculosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehiculos
     */
    select?: vehiculosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiculosInclude<ExtArgs> | null
    /**
     * The data needed to create a vehiculos.
     */
    data: XOR<vehiculosCreateInput, vehiculosUncheckedCreateInput>
  }

  /**
   * vehiculos createMany
   */
  export type vehiculosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vehiculos.
     */
    data: vehiculosCreateManyInput | vehiculosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * vehiculos createManyAndReturn
   */
  export type vehiculosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehiculos
     */
    select?: vehiculosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many vehiculos.
     */
    data: vehiculosCreateManyInput | vehiculosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiculosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * vehiculos update
   */
  export type vehiculosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehiculos
     */
    select?: vehiculosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiculosInclude<ExtArgs> | null
    /**
     * The data needed to update a vehiculos.
     */
    data: XOR<vehiculosUpdateInput, vehiculosUncheckedUpdateInput>
    /**
     * Choose, which vehiculos to update.
     */
    where: vehiculosWhereUniqueInput
  }

  /**
   * vehiculos updateMany
   */
  export type vehiculosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vehiculos.
     */
    data: XOR<vehiculosUpdateManyMutationInput, vehiculosUncheckedUpdateManyInput>
    /**
     * Filter which vehiculos to update
     */
    where?: vehiculosWhereInput
  }

  /**
   * vehiculos upsert
   */
  export type vehiculosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehiculos
     */
    select?: vehiculosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiculosInclude<ExtArgs> | null
    /**
     * The filter to search for the vehiculos to update in case it exists.
     */
    where: vehiculosWhereUniqueInput
    /**
     * In case the vehiculos found by the `where` argument doesn't exist, create a new vehiculos with this data.
     */
    create: XOR<vehiculosCreateInput, vehiculosUncheckedCreateInput>
    /**
     * In case the vehiculos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vehiculosUpdateInput, vehiculosUncheckedUpdateInput>
  }

  /**
   * vehiculos delete
   */
  export type vehiculosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehiculos
     */
    select?: vehiculosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiculosInclude<ExtArgs> | null
    /**
     * Filter which vehiculos to delete.
     */
    where: vehiculosWhereUniqueInput
  }

  /**
   * vehiculos deleteMany
   */
  export type vehiculosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehiculos to delete
     */
    where?: vehiculosWhereInput
  }

  /**
   * vehiculos.ordenes_servicio
   */
  export type vehiculos$ordenes_servicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_servicio
     */
    select?: ordenes_servicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordenes_servicioInclude<ExtArgs> | null
    where?: ordenes_servicioWhereInput
    orderBy?: ordenes_servicioOrderByWithRelationInput | ordenes_servicioOrderByWithRelationInput[]
    cursor?: ordenes_servicioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ordenes_servicioScalarFieldEnum | Ordenes_servicioScalarFieldEnum[]
  }

  /**
   * vehiculos without action
   */
  export type vehiculosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehiculos
     */
    select?: vehiculosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiculosInclude<ExtArgs> | null
  }


  /**
   * Model servicios
   */

  export type AggregateServicios = {
    _count: ServiciosCountAggregateOutputType | null
    _avg: ServiciosAvgAggregateOutputType | null
    _sum: ServiciosSumAggregateOutputType | null
    _min: ServiciosMinAggregateOutputType | null
    _max: ServiciosMaxAggregateOutputType | null
  }

  export type ServiciosAvgAggregateOutputType = {
    id_servicio: number | null
    precio: Decimal | null
    tiempo_est: number | null
  }

  export type ServiciosSumAggregateOutputType = {
    id_servicio: number | null
    precio: Decimal | null
    tiempo_est: number | null
  }

  export type ServiciosMinAggregateOutputType = {
    id_servicio: number | null
    nombre: string | null
    descripcion: string | null
    precio: Decimal | null
    tiempo_est: number | null
    activo: boolean | null
    created_at: Date | null
  }

  export type ServiciosMaxAggregateOutputType = {
    id_servicio: number | null
    nombre: string | null
    descripcion: string | null
    precio: Decimal | null
    tiempo_est: number | null
    activo: boolean | null
    created_at: Date | null
  }

  export type ServiciosCountAggregateOutputType = {
    id_servicio: number
    nombre: number
    descripcion: number
    precio: number
    tiempo_est: number
    activo: number
    created_at: number
    _all: number
  }


  export type ServiciosAvgAggregateInputType = {
    id_servicio?: true
    precio?: true
    tiempo_est?: true
  }

  export type ServiciosSumAggregateInputType = {
    id_servicio?: true
    precio?: true
    tiempo_est?: true
  }

  export type ServiciosMinAggregateInputType = {
    id_servicio?: true
    nombre?: true
    descripcion?: true
    precio?: true
    tiempo_est?: true
    activo?: true
    created_at?: true
  }

  export type ServiciosMaxAggregateInputType = {
    id_servicio?: true
    nombre?: true
    descripcion?: true
    precio?: true
    tiempo_est?: true
    activo?: true
    created_at?: true
  }

  export type ServiciosCountAggregateInputType = {
    id_servicio?: true
    nombre?: true
    descripcion?: true
    precio?: true
    tiempo_est?: true
    activo?: true
    created_at?: true
    _all?: true
  }

  export type ServiciosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicios to aggregate.
     */
    where?: serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     */
    orderBy?: serviciosOrderByWithRelationInput | serviciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicios
    **/
    _count?: true | ServiciosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiciosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiciosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiciosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiciosMaxAggregateInputType
  }

  export type GetServiciosAggregateType<T extends ServiciosAggregateArgs> = {
        [P in keyof T & keyof AggregateServicios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicios[P]>
      : GetScalarType<T[P], AggregateServicios[P]>
  }




  export type serviciosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serviciosWhereInput
    orderBy?: serviciosOrderByWithAggregationInput | serviciosOrderByWithAggregationInput[]
    by: ServiciosScalarFieldEnum[] | ServiciosScalarFieldEnum
    having?: serviciosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiciosCountAggregateInputType | true
    _avg?: ServiciosAvgAggregateInputType
    _sum?: ServiciosSumAggregateInputType
    _min?: ServiciosMinAggregateInputType
    _max?: ServiciosMaxAggregateInputType
  }

  export type ServiciosGroupByOutputType = {
    id_servicio: number
    nombre: string
    descripcion: string | null
    precio: Decimal
    tiempo_est: number | null
    activo: boolean
    created_at: Date | null
    _count: ServiciosCountAggregateOutputType | null
    _avg: ServiciosAvgAggregateOutputType | null
    _sum: ServiciosSumAggregateOutputType | null
    _min: ServiciosMinAggregateOutputType | null
    _max: ServiciosMaxAggregateOutputType | null
  }

  type GetServiciosGroupByPayload<T extends serviciosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiciosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiciosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiciosGroupByOutputType[P]>
            : GetScalarType<T[P], ServiciosGroupByOutputType[P]>
        }
      >
    >


  export type serviciosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_servicio?: boolean
    nombre?: boolean
    descripcion?: boolean
    precio?: boolean
    tiempo_est?: boolean
    activo?: boolean
    created_at?: boolean
    detalle_orden?: boolean | servicios$detalle_ordenArgs<ExtArgs>
    _count?: boolean | ServiciosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicios"]>

  export type serviciosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_servicio?: boolean
    nombre?: boolean
    descripcion?: boolean
    precio?: boolean
    tiempo_est?: boolean
    activo?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["servicios"]>

  export type serviciosSelectScalar = {
    id_servicio?: boolean
    nombre?: boolean
    descripcion?: boolean
    precio?: boolean
    tiempo_est?: boolean
    activo?: boolean
    created_at?: boolean
  }

  export type serviciosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detalle_orden?: boolean | servicios$detalle_ordenArgs<ExtArgs>
    _count?: boolean | ServiciosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type serviciosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $serviciosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "servicios"
    objects: {
      detalle_orden: Prisma.$detalle_ordenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_servicio: number
      nombre: string
      descripcion: string | null
      precio: Prisma.Decimal
      tiempo_est: number | null
      activo: boolean
      created_at: Date | null
    }, ExtArgs["result"]["servicios"]>
    composites: {}
  }

  type serviciosGetPayload<S extends boolean | null | undefined | serviciosDefaultArgs> = $Result.GetResult<Prisma.$serviciosPayload, S>

  type serviciosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<serviciosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiciosCountAggregateInputType | true
    }

  export interface serviciosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['servicios'], meta: { name: 'servicios' } }
    /**
     * Find zero or one Servicios that matches the filter.
     * @param {serviciosFindUniqueArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends serviciosFindUniqueArgs>(args: SelectSubset<T, serviciosFindUniqueArgs<ExtArgs>>): Prisma__serviciosClient<$Result.GetResult<Prisma.$serviciosPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Servicios that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {serviciosFindUniqueOrThrowArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends serviciosFindUniqueOrThrowArgs>(args: SelectSubset<T, serviciosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__serviciosClient<$Result.GetResult<Prisma.$serviciosPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosFindFirstArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends serviciosFindFirstArgs>(args?: SelectSubset<T, serviciosFindFirstArgs<ExtArgs>>): Prisma__serviciosClient<$Result.GetResult<Prisma.$serviciosPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Servicios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosFindFirstOrThrowArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends serviciosFindFirstOrThrowArgs>(args?: SelectSubset<T, serviciosFindFirstOrThrowArgs<ExtArgs>>): Prisma__serviciosClient<$Result.GetResult<Prisma.$serviciosPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicios
     * const servicios = await prisma.servicios.findMany()
     * 
     * // Get first 10 Servicios
     * const servicios = await prisma.servicios.findMany({ take: 10 })
     * 
     * // Only select the `id_servicio`
     * const serviciosWithId_servicioOnly = await prisma.servicios.findMany({ select: { id_servicio: true } })
     * 
     */
    findMany<T extends serviciosFindManyArgs>(args?: SelectSubset<T, serviciosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serviciosPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Servicios.
     * @param {serviciosCreateArgs} args - Arguments to create a Servicios.
     * @example
     * // Create one Servicios
     * const Servicios = await prisma.servicios.create({
     *   data: {
     *     // ... data to create a Servicios
     *   }
     * })
     * 
     */
    create<T extends serviciosCreateArgs>(args: SelectSubset<T, serviciosCreateArgs<ExtArgs>>): Prisma__serviciosClient<$Result.GetResult<Prisma.$serviciosPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Servicios.
     * @param {serviciosCreateManyArgs} args - Arguments to create many Servicios.
     * @example
     * // Create many Servicios
     * const servicios = await prisma.servicios.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends serviciosCreateManyArgs>(args?: SelectSubset<T, serviciosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Servicios and returns the data saved in the database.
     * @param {serviciosCreateManyAndReturnArgs} args - Arguments to create many Servicios.
     * @example
     * // Create many Servicios
     * const servicios = await prisma.servicios.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Servicios and only return the `id_servicio`
     * const serviciosWithId_servicioOnly = await prisma.servicios.createManyAndReturn({ 
     *   select: { id_servicio: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends serviciosCreateManyAndReturnArgs>(args?: SelectSubset<T, serviciosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serviciosPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Servicios.
     * @param {serviciosDeleteArgs} args - Arguments to delete one Servicios.
     * @example
     * // Delete one Servicios
     * const Servicios = await prisma.servicios.delete({
     *   where: {
     *     // ... filter to delete one Servicios
     *   }
     * })
     * 
     */
    delete<T extends serviciosDeleteArgs>(args: SelectSubset<T, serviciosDeleteArgs<ExtArgs>>): Prisma__serviciosClient<$Result.GetResult<Prisma.$serviciosPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Servicios.
     * @param {serviciosUpdateArgs} args - Arguments to update one Servicios.
     * @example
     * // Update one Servicios
     * const servicios = await prisma.servicios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends serviciosUpdateArgs>(args: SelectSubset<T, serviciosUpdateArgs<ExtArgs>>): Prisma__serviciosClient<$Result.GetResult<Prisma.$serviciosPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Servicios.
     * @param {serviciosDeleteManyArgs} args - Arguments to filter Servicios to delete.
     * @example
     * // Delete a few Servicios
     * const { count } = await prisma.servicios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends serviciosDeleteManyArgs>(args?: SelectSubset<T, serviciosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicios
     * const servicios = await prisma.servicios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends serviciosUpdateManyArgs>(args: SelectSubset<T, serviciosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicios.
     * @param {serviciosUpsertArgs} args - Arguments to update or create a Servicios.
     * @example
     * // Update or create a Servicios
     * const servicios = await prisma.servicios.upsert({
     *   create: {
     *     // ... data to create a Servicios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicios we want to update
     *   }
     * })
     */
    upsert<T extends serviciosUpsertArgs>(args: SelectSubset<T, serviciosUpsertArgs<ExtArgs>>): Prisma__serviciosClient<$Result.GetResult<Prisma.$serviciosPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosCountArgs} args - Arguments to filter Servicios to count.
     * @example
     * // Count the number of Servicios
     * const count = await prisma.servicios.count({
     *   where: {
     *     // ... the filter for the Servicios we want to count
     *   }
     * })
    **/
    count<T extends serviciosCountArgs>(
      args?: Subset<T, serviciosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiciosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiciosAggregateArgs>(args: Subset<T, ServiciosAggregateArgs>): Prisma.PrismaPromise<GetServiciosAggregateType<T>>

    /**
     * Group by Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends serviciosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: serviciosGroupByArgs['orderBy'] }
        : { orderBy?: serviciosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, serviciosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiciosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the servicios model
   */
  readonly fields: serviciosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for servicios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__serviciosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    detalle_orden<T extends servicios$detalle_ordenArgs<ExtArgs> = {}>(args?: Subset<T, servicios$detalle_ordenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detalle_ordenPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the servicios model
   */ 
  interface serviciosFieldRefs {
    readonly id_servicio: FieldRef<"servicios", 'Int'>
    readonly nombre: FieldRef<"servicios", 'String'>
    readonly descripcion: FieldRef<"servicios", 'String'>
    readonly precio: FieldRef<"servicios", 'Decimal'>
    readonly tiempo_est: FieldRef<"servicios", 'Int'>
    readonly activo: FieldRef<"servicios", 'Boolean'>
    readonly created_at: FieldRef<"servicios", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * servicios findUnique
   */
  export type serviciosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviciosInclude<ExtArgs> | null
    /**
     * Filter, which servicios to fetch.
     */
    where: serviciosWhereUniqueInput
  }

  /**
   * servicios findUniqueOrThrow
   */
  export type serviciosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviciosInclude<ExtArgs> | null
    /**
     * Filter, which servicios to fetch.
     */
    where: serviciosWhereUniqueInput
  }

  /**
   * servicios findFirst
   */
  export type serviciosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviciosInclude<ExtArgs> | null
    /**
     * Filter, which servicios to fetch.
     */
    where?: serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     */
    orderBy?: serviciosOrderByWithRelationInput | serviciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicios.
     */
    cursor?: serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicios.
     */
    distinct?: ServiciosScalarFieldEnum | ServiciosScalarFieldEnum[]
  }

  /**
   * servicios findFirstOrThrow
   */
  export type serviciosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviciosInclude<ExtArgs> | null
    /**
     * Filter, which servicios to fetch.
     */
    where?: serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     */
    orderBy?: serviciosOrderByWithRelationInput | serviciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicios.
     */
    cursor?: serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicios.
     */
    distinct?: ServiciosScalarFieldEnum | ServiciosScalarFieldEnum[]
  }

  /**
   * servicios findMany
   */
  export type serviciosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviciosInclude<ExtArgs> | null
    /**
     * Filter, which servicios to fetch.
     */
    where?: serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     */
    orderBy?: serviciosOrderByWithRelationInput | serviciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicios.
     */
    cursor?: serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     */
    skip?: number
    distinct?: ServiciosScalarFieldEnum | ServiciosScalarFieldEnum[]
  }

  /**
   * servicios create
   */
  export type serviciosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviciosInclude<ExtArgs> | null
    /**
     * The data needed to create a servicios.
     */
    data: XOR<serviciosCreateInput, serviciosUncheckedCreateInput>
  }

  /**
   * servicios createMany
   */
  export type serviciosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many servicios.
     */
    data: serviciosCreateManyInput | serviciosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * servicios createManyAndReturn
   */
  export type serviciosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many servicios.
     */
    data: serviciosCreateManyInput | serviciosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * servicios update
   */
  export type serviciosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviciosInclude<ExtArgs> | null
    /**
     * The data needed to update a servicios.
     */
    data: XOR<serviciosUpdateInput, serviciosUncheckedUpdateInput>
    /**
     * Choose, which servicios to update.
     */
    where: serviciosWhereUniqueInput
  }

  /**
   * servicios updateMany
   */
  export type serviciosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update servicios.
     */
    data: XOR<serviciosUpdateManyMutationInput, serviciosUncheckedUpdateManyInput>
    /**
     * Filter which servicios to update
     */
    where?: serviciosWhereInput
  }

  /**
   * servicios upsert
   */
  export type serviciosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviciosInclude<ExtArgs> | null
    /**
     * The filter to search for the servicios to update in case it exists.
     */
    where: serviciosWhereUniqueInput
    /**
     * In case the servicios found by the `where` argument doesn't exist, create a new servicios with this data.
     */
    create: XOR<serviciosCreateInput, serviciosUncheckedCreateInput>
    /**
     * In case the servicios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<serviciosUpdateInput, serviciosUncheckedUpdateInput>
  }

  /**
   * servicios delete
   */
  export type serviciosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviciosInclude<ExtArgs> | null
    /**
     * Filter which servicios to delete.
     */
    where: serviciosWhereUniqueInput
  }

  /**
   * servicios deleteMany
   */
  export type serviciosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicios to delete
     */
    where?: serviciosWhereInput
  }

  /**
   * servicios.detalle_orden
   */
  export type servicios$detalle_ordenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden
     */
    select?: detalle_ordenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_ordenInclude<ExtArgs> | null
    where?: detalle_ordenWhereInput
    orderBy?: detalle_ordenOrderByWithRelationInput | detalle_ordenOrderByWithRelationInput[]
    cursor?: detalle_ordenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detalle_ordenScalarFieldEnum | Detalle_ordenScalarFieldEnum[]
  }

  /**
   * servicios without action
   */
  export type serviciosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviciosInclude<ExtArgs> | null
  }


  /**
   * Model empleados
   */

  export type AggregateEmpleados = {
    _count: EmpleadosCountAggregateOutputType | null
    _avg: EmpleadosAvgAggregateOutputType | null
    _sum: EmpleadosSumAggregateOutputType | null
    _min: EmpleadosMinAggregateOutputType | null
    _max: EmpleadosMaxAggregateOutputType | null
  }

  export type EmpleadosAvgAggregateOutputType = {
    id_empleado: number | null
    salario: Decimal | null
  }

  export type EmpleadosSumAggregateOutputType = {
    id_empleado: number | null
    salario: Decimal | null
  }

  export type EmpleadosMinAggregateOutputType = {
    id_empleado: number | null
    nombre: string | null
    especialidad: string | null
    telefono: string | null
    salario: Decimal | null
    activo: boolean | null
    created_at: Date | null
  }

  export type EmpleadosMaxAggregateOutputType = {
    id_empleado: number | null
    nombre: string | null
    especialidad: string | null
    telefono: string | null
    salario: Decimal | null
    activo: boolean | null
    created_at: Date | null
  }

  export type EmpleadosCountAggregateOutputType = {
    id_empleado: number
    nombre: number
    especialidad: number
    telefono: number
    salario: number
    activo: number
    created_at: number
    _all: number
  }


  export type EmpleadosAvgAggregateInputType = {
    id_empleado?: true
    salario?: true
  }

  export type EmpleadosSumAggregateInputType = {
    id_empleado?: true
    salario?: true
  }

  export type EmpleadosMinAggregateInputType = {
    id_empleado?: true
    nombre?: true
    especialidad?: true
    telefono?: true
    salario?: true
    activo?: true
    created_at?: true
  }

  export type EmpleadosMaxAggregateInputType = {
    id_empleado?: true
    nombre?: true
    especialidad?: true
    telefono?: true
    salario?: true
    activo?: true
    created_at?: true
  }

  export type EmpleadosCountAggregateInputType = {
    id_empleado?: true
    nombre?: true
    especialidad?: true
    telefono?: true
    salario?: true
    activo?: true
    created_at?: true
    _all?: true
  }

  export type EmpleadosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which empleados to aggregate.
     */
    where?: empleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleados to fetch.
     */
    orderBy?: empleadosOrderByWithRelationInput | empleadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: empleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned empleados
    **/
    _count?: true | EmpleadosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmpleadosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmpleadosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpleadosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpleadosMaxAggregateInputType
  }

  export type GetEmpleadosAggregateType<T extends EmpleadosAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpleados]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpleados[P]>
      : GetScalarType<T[P], AggregateEmpleados[P]>
  }




  export type empleadosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: empleadosWhereInput
    orderBy?: empleadosOrderByWithAggregationInput | empleadosOrderByWithAggregationInput[]
    by: EmpleadosScalarFieldEnum[] | EmpleadosScalarFieldEnum
    having?: empleadosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpleadosCountAggregateInputType | true
    _avg?: EmpleadosAvgAggregateInputType
    _sum?: EmpleadosSumAggregateInputType
    _min?: EmpleadosMinAggregateInputType
    _max?: EmpleadosMaxAggregateInputType
  }

  export type EmpleadosGroupByOutputType = {
    id_empleado: number
    nombre: string
    especialidad: string | null
    telefono: string | null
    salario: Decimal | null
    activo: boolean
    created_at: Date | null
    _count: EmpleadosCountAggregateOutputType | null
    _avg: EmpleadosAvgAggregateOutputType | null
    _sum: EmpleadosSumAggregateOutputType | null
    _min: EmpleadosMinAggregateOutputType | null
    _max: EmpleadosMaxAggregateOutputType | null
  }

  type GetEmpleadosGroupByPayload<T extends empleadosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpleadosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpleadosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpleadosGroupByOutputType[P]>
            : GetScalarType<T[P], EmpleadosGroupByOutputType[P]>
        }
      >
    >


  export type empleadosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_empleado?: boolean
    nombre?: boolean
    especialidad?: boolean
    telefono?: boolean
    salario?: boolean
    activo?: boolean
    created_at?: boolean
    ordenes_servicio?: boolean | empleados$ordenes_servicioArgs<ExtArgs>
    _count?: boolean | EmpleadosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["empleados"]>

  export type empleadosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_empleado?: boolean
    nombre?: boolean
    especialidad?: boolean
    telefono?: boolean
    salario?: boolean
    activo?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["empleados"]>

  export type empleadosSelectScalar = {
    id_empleado?: boolean
    nombre?: boolean
    especialidad?: boolean
    telefono?: boolean
    salario?: boolean
    activo?: boolean
    created_at?: boolean
  }

  export type empleadosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ordenes_servicio?: boolean | empleados$ordenes_servicioArgs<ExtArgs>
    _count?: boolean | EmpleadosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type empleadosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $empleadosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "empleados"
    objects: {
      ordenes_servicio: Prisma.$ordenes_servicioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_empleado: number
      nombre: string
      especialidad: string | null
      telefono: string | null
      salario: Prisma.Decimal | null
      activo: boolean
      created_at: Date | null
    }, ExtArgs["result"]["empleados"]>
    composites: {}
  }

  type empleadosGetPayload<S extends boolean | null | undefined | empleadosDefaultArgs> = $Result.GetResult<Prisma.$empleadosPayload, S>

  type empleadosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<empleadosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmpleadosCountAggregateInputType | true
    }

  export interface empleadosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['empleados'], meta: { name: 'empleados' } }
    /**
     * Find zero or one Empleados that matches the filter.
     * @param {empleadosFindUniqueArgs} args - Arguments to find a Empleados
     * @example
     * // Get one Empleados
     * const empleados = await prisma.empleados.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends empleadosFindUniqueArgs>(args: SelectSubset<T, empleadosFindUniqueArgs<ExtArgs>>): Prisma__empleadosClient<$Result.GetResult<Prisma.$empleadosPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Empleados that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {empleadosFindUniqueOrThrowArgs} args - Arguments to find a Empleados
     * @example
     * // Get one Empleados
     * const empleados = await prisma.empleados.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends empleadosFindUniqueOrThrowArgs>(args: SelectSubset<T, empleadosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__empleadosClient<$Result.GetResult<Prisma.$empleadosPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Empleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadosFindFirstArgs} args - Arguments to find a Empleados
     * @example
     * // Get one Empleados
     * const empleados = await prisma.empleados.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends empleadosFindFirstArgs>(args?: SelectSubset<T, empleadosFindFirstArgs<ExtArgs>>): Prisma__empleadosClient<$Result.GetResult<Prisma.$empleadosPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Empleados that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadosFindFirstOrThrowArgs} args - Arguments to find a Empleados
     * @example
     * // Get one Empleados
     * const empleados = await prisma.empleados.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends empleadosFindFirstOrThrowArgs>(args?: SelectSubset<T, empleadosFindFirstOrThrowArgs<ExtArgs>>): Prisma__empleadosClient<$Result.GetResult<Prisma.$empleadosPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Empleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empleados
     * const empleados = await prisma.empleados.findMany()
     * 
     * // Get first 10 Empleados
     * const empleados = await prisma.empleados.findMany({ take: 10 })
     * 
     * // Only select the `id_empleado`
     * const empleadosWithId_empleadoOnly = await prisma.empleados.findMany({ select: { id_empleado: true } })
     * 
     */
    findMany<T extends empleadosFindManyArgs>(args?: SelectSubset<T, empleadosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$empleadosPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Empleados.
     * @param {empleadosCreateArgs} args - Arguments to create a Empleados.
     * @example
     * // Create one Empleados
     * const Empleados = await prisma.empleados.create({
     *   data: {
     *     // ... data to create a Empleados
     *   }
     * })
     * 
     */
    create<T extends empleadosCreateArgs>(args: SelectSubset<T, empleadosCreateArgs<ExtArgs>>): Prisma__empleadosClient<$Result.GetResult<Prisma.$empleadosPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Empleados.
     * @param {empleadosCreateManyArgs} args - Arguments to create many Empleados.
     * @example
     * // Create many Empleados
     * const empleados = await prisma.empleados.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends empleadosCreateManyArgs>(args?: SelectSubset<T, empleadosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Empleados and returns the data saved in the database.
     * @param {empleadosCreateManyAndReturnArgs} args - Arguments to create many Empleados.
     * @example
     * // Create many Empleados
     * const empleados = await prisma.empleados.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Empleados and only return the `id_empleado`
     * const empleadosWithId_empleadoOnly = await prisma.empleados.createManyAndReturn({ 
     *   select: { id_empleado: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends empleadosCreateManyAndReturnArgs>(args?: SelectSubset<T, empleadosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$empleadosPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Empleados.
     * @param {empleadosDeleteArgs} args - Arguments to delete one Empleados.
     * @example
     * // Delete one Empleados
     * const Empleados = await prisma.empleados.delete({
     *   where: {
     *     // ... filter to delete one Empleados
     *   }
     * })
     * 
     */
    delete<T extends empleadosDeleteArgs>(args: SelectSubset<T, empleadosDeleteArgs<ExtArgs>>): Prisma__empleadosClient<$Result.GetResult<Prisma.$empleadosPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Empleados.
     * @param {empleadosUpdateArgs} args - Arguments to update one Empleados.
     * @example
     * // Update one Empleados
     * const empleados = await prisma.empleados.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends empleadosUpdateArgs>(args: SelectSubset<T, empleadosUpdateArgs<ExtArgs>>): Prisma__empleadosClient<$Result.GetResult<Prisma.$empleadosPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Empleados.
     * @param {empleadosDeleteManyArgs} args - Arguments to filter Empleados to delete.
     * @example
     * // Delete a few Empleados
     * const { count } = await prisma.empleados.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends empleadosDeleteManyArgs>(args?: SelectSubset<T, empleadosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empleados
     * const empleados = await prisma.empleados.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends empleadosUpdateManyArgs>(args: SelectSubset<T, empleadosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Empleados.
     * @param {empleadosUpsertArgs} args - Arguments to update or create a Empleados.
     * @example
     * // Update or create a Empleados
     * const empleados = await prisma.empleados.upsert({
     *   create: {
     *     // ... data to create a Empleados
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empleados we want to update
     *   }
     * })
     */
    upsert<T extends empleadosUpsertArgs>(args: SelectSubset<T, empleadosUpsertArgs<ExtArgs>>): Prisma__empleadosClient<$Result.GetResult<Prisma.$empleadosPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadosCountArgs} args - Arguments to filter Empleados to count.
     * @example
     * // Count the number of Empleados
     * const count = await prisma.empleados.count({
     *   where: {
     *     // ... the filter for the Empleados we want to count
     *   }
     * })
    **/
    count<T extends empleadosCountArgs>(
      args?: Subset<T, empleadosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpleadosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpleadosAggregateArgs>(args: Subset<T, EmpleadosAggregateArgs>): Prisma.PrismaPromise<GetEmpleadosAggregateType<T>>

    /**
     * Group by Empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends empleadosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: empleadosGroupByArgs['orderBy'] }
        : { orderBy?: empleadosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, empleadosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpleadosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the empleados model
   */
  readonly fields: empleadosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for empleados.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__empleadosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ordenes_servicio<T extends empleados$ordenes_servicioArgs<ExtArgs> = {}>(args?: Subset<T, empleados$ordenes_servicioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordenes_servicioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the empleados model
   */ 
  interface empleadosFieldRefs {
    readonly id_empleado: FieldRef<"empleados", 'Int'>
    readonly nombre: FieldRef<"empleados", 'String'>
    readonly especialidad: FieldRef<"empleados", 'String'>
    readonly telefono: FieldRef<"empleados", 'String'>
    readonly salario: FieldRef<"empleados", 'Decimal'>
    readonly activo: FieldRef<"empleados", 'Boolean'>
    readonly created_at: FieldRef<"empleados", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * empleados findUnique
   */
  export type empleadosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleados
     */
    select?: empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empleadosInclude<ExtArgs> | null
    /**
     * Filter, which empleados to fetch.
     */
    where: empleadosWhereUniqueInput
  }

  /**
   * empleados findUniqueOrThrow
   */
  export type empleadosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleados
     */
    select?: empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empleadosInclude<ExtArgs> | null
    /**
     * Filter, which empleados to fetch.
     */
    where: empleadosWhereUniqueInput
  }

  /**
   * empleados findFirst
   */
  export type empleadosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleados
     */
    select?: empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empleadosInclude<ExtArgs> | null
    /**
     * Filter, which empleados to fetch.
     */
    where?: empleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleados to fetch.
     */
    orderBy?: empleadosOrderByWithRelationInput | empleadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for empleados.
     */
    cursor?: empleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of empleados.
     */
    distinct?: EmpleadosScalarFieldEnum | EmpleadosScalarFieldEnum[]
  }

  /**
   * empleados findFirstOrThrow
   */
  export type empleadosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleados
     */
    select?: empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empleadosInclude<ExtArgs> | null
    /**
     * Filter, which empleados to fetch.
     */
    where?: empleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleados to fetch.
     */
    orderBy?: empleadosOrderByWithRelationInput | empleadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for empleados.
     */
    cursor?: empleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of empleados.
     */
    distinct?: EmpleadosScalarFieldEnum | EmpleadosScalarFieldEnum[]
  }

  /**
   * empleados findMany
   */
  export type empleadosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleados
     */
    select?: empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empleadosInclude<ExtArgs> | null
    /**
     * Filter, which empleados to fetch.
     */
    where?: empleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleados to fetch.
     */
    orderBy?: empleadosOrderByWithRelationInput | empleadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing empleados.
     */
    cursor?: empleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleados.
     */
    skip?: number
    distinct?: EmpleadosScalarFieldEnum | EmpleadosScalarFieldEnum[]
  }

  /**
   * empleados create
   */
  export type empleadosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleados
     */
    select?: empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empleadosInclude<ExtArgs> | null
    /**
     * The data needed to create a empleados.
     */
    data: XOR<empleadosCreateInput, empleadosUncheckedCreateInput>
  }

  /**
   * empleados createMany
   */
  export type empleadosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many empleados.
     */
    data: empleadosCreateManyInput | empleadosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * empleados createManyAndReturn
   */
  export type empleadosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleados
     */
    select?: empleadosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many empleados.
     */
    data: empleadosCreateManyInput | empleadosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * empleados update
   */
  export type empleadosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleados
     */
    select?: empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empleadosInclude<ExtArgs> | null
    /**
     * The data needed to update a empleados.
     */
    data: XOR<empleadosUpdateInput, empleadosUncheckedUpdateInput>
    /**
     * Choose, which empleados to update.
     */
    where: empleadosWhereUniqueInput
  }

  /**
   * empleados updateMany
   */
  export type empleadosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update empleados.
     */
    data: XOR<empleadosUpdateManyMutationInput, empleadosUncheckedUpdateManyInput>
    /**
     * Filter which empleados to update
     */
    where?: empleadosWhereInput
  }

  /**
   * empleados upsert
   */
  export type empleadosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleados
     */
    select?: empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empleadosInclude<ExtArgs> | null
    /**
     * The filter to search for the empleados to update in case it exists.
     */
    where: empleadosWhereUniqueInput
    /**
     * In case the empleados found by the `where` argument doesn't exist, create a new empleados with this data.
     */
    create: XOR<empleadosCreateInput, empleadosUncheckedCreateInput>
    /**
     * In case the empleados was found with the provided `where` argument, update it with this data.
     */
    update: XOR<empleadosUpdateInput, empleadosUncheckedUpdateInput>
  }

  /**
   * empleados delete
   */
  export type empleadosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleados
     */
    select?: empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empleadosInclude<ExtArgs> | null
    /**
     * Filter which empleados to delete.
     */
    where: empleadosWhereUniqueInput
  }

  /**
   * empleados deleteMany
   */
  export type empleadosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which empleados to delete
     */
    where?: empleadosWhereInput
  }

  /**
   * empleados.ordenes_servicio
   */
  export type empleados$ordenes_servicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_servicio
     */
    select?: ordenes_servicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordenes_servicioInclude<ExtArgs> | null
    where?: ordenes_servicioWhereInput
    orderBy?: ordenes_servicioOrderByWithRelationInput | ordenes_servicioOrderByWithRelationInput[]
    cursor?: ordenes_servicioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ordenes_servicioScalarFieldEnum | Ordenes_servicioScalarFieldEnum[]
  }

  /**
   * empleados without action
   */
  export type empleadosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleados
     */
    select?: empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empleadosInclude<ExtArgs> | null
  }


  /**
   * Model ordenes_servicio
   */

  export type AggregateOrdenes_servicio = {
    _count: Ordenes_servicioCountAggregateOutputType | null
    _avg: Ordenes_servicioAvgAggregateOutputType | null
    _sum: Ordenes_servicioSumAggregateOutputType | null
    _min: Ordenes_servicioMinAggregateOutputType | null
    _max: Ordenes_servicioMaxAggregateOutputType | null
  }

  export type Ordenes_servicioAvgAggregateOutputType = {
    id_orden: number | null
    id_vehiculo: number | null
    id_empleado: number | null
    kilometraje: number | null
  }

  export type Ordenes_servicioSumAggregateOutputType = {
    id_orden: number | null
    id_vehiculo: number | null
    id_empleado: number | null
    kilometraje: number | null
  }

  export type Ordenes_servicioMinAggregateOutputType = {
    id_orden: number | null
    id_vehiculo: number | null
    id_empleado: number | null
    fecha_entrada: Date | null
    fecha_salida: Date | null
    observaciones: string | null
    estado: string | null
    kilometraje: number | null
    created_at: Date | null
  }

  export type Ordenes_servicioMaxAggregateOutputType = {
    id_orden: number | null
    id_vehiculo: number | null
    id_empleado: number | null
    fecha_entrada: Date | null
    fecha_salida: Date | null
    observaciones: string | null
    estado: string | null
    kilometraje: number | null
    created_at: Date | null
  }

  export type Ordenes_servicioCountAggregateOutputType = {
    id_orden: number
    id_vehiculo: number
    id_empleado: number
    fecha_entrada: number
    fecha_salida: number
    observaciones: number
    estado: number
    kilometraje: number
    created_at: number
    _all: number
  }


  export type Ordenes_servicioAvgAggregateInputType = {
    id_orden?: true
    id_vehiculo?: true
    id_empleado?: true
    kilometraje?: true
  }

  export type Ordenes_servicioSumAggregateInputType = {
    id_orden?: true
    id_vehiculo?: true
    id_empleado?: true
    kilometraje?: true
  }

  export type Ordenes_servicioMinAggregateInputType = {
    id_orden?: true
    id_vehiculo?: true
    id_empleado?: true
    fecha_entrada?: true
    fecha_salida?: true
    observaciones?: true
    estado?: true
    kilometraje?: true
    created_at?: true
  }

  export type Ordenes_servicioMaxAggregateInputType = {
    id_orden?: true
    id_vehiculo?: true
    id_empleado?: true
    fecha_entrada?: true
    fecha_salida?: true
    observaciones?: true
    estado?: true
    kilometraje?: true
    created_at?: true
  }

  export type Ordenes_servicioCountAggregateInputType = {
    id_orden?: true
    id_vehiculo?: true
    id_empleado?: true
    fecha_entrada?: true
    fecha_salida?: true
    observaciones?: true
    estado?: true
    kilometraje?: true
    created_at?: true
    _all?: true
  }

  export type Ordenes_servicioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ordenes_servicio to aggregate.
     */
    where?: ordenes_servicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ordenes_servicios to fetch.
     */
    orderBy?: ordenes_servicioOrderByWithRelationInput | ordenes_servicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ordenes_servicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ordenes_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ordenes_servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ordenes_servicios
    **/
    _count?: true | Ordenes_servicioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ordenes_servicioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ordenes_servicioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ordenes_servicioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ordenes_servicioMaxAggregateInputType
  }

  export type GetOrdenes_servicioAggregateType<T extends Ordenes_servicioAggregateArgs> = {
        [P in keyof T & keyof AggregateOrdenes_servicio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrdenes_servicio[P]>
      : GetScalarType<T[P], AggregateOrdenes_servicio[P]>
  }




  export type ordenes_servicioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordenes_servicioWhereInput
    orderBy?: ordenes_servicioOrderByWithAggregationInput | ordenes_servicioOrderByWithAggregationInput[]
    by: Ordenes_servicioScalarFieldEnum[] | Ordenes_servicioScalarFieldEnum
    having?: ordenes_servicioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ordenes_servicioCountAggregateInputType | true
    _avg?: Ordenes_servicioAvgAggregateInputType
    _sum?: Ordenes_servicioSumAggregateInputType
    _min?: Ordenes_servicioMinAggregateInputType
    _max?: Ordenes_servicioMaxAggregateInputType
  }

  export type Ordenes_servicioGroupByOutputType = {
    id_orden: number
    id_vehiculo: number
    id_empleado: number | null
    fecha_entrada: Date
    fecha_salida: Date | null
    observaciones: string | null
    estado: string
    kilometraje: number | null
    created_at: Date | null
    _count: Ordenes_servicioCountAggregateOutputType | null
    _avg: Ordenes_servicioAvgAggregateOutputType | null
    _sum: Ordenes_servicioSumAggregateOutputType | null
    _min: Ordenes_servicioMinAggregateOutputType | null
    _max: Ordenes_servicioMaxAggregateOutputType | null
  }

  type GetOrdenes_servicioGroupByPayload<T extends ordenes_servicioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ordenes_servicioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ordenes_servicioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ordenes_servicioGroupByOutputType[P]>
            : GetScalarType<T[P], Ordenes_servicioGroupByOutputType[P]>
        }
      >
    >


  export type ordenes_servicioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_orden?: boolean
    id_vehiculo?: boolean
    id_empleado?: boolean
    fecha_entrada?: boolean
    fecha_salida?: boolean
    observaciones?: boolean
    estado?: boolean
    kilometraje?: boolean
    created_at?: boolean
    vehiculo?: boolean | vehiculosDefaultArgs<ExtArgs>
    empleado?: boolean | ordenes_servicio$empleadoArgs<ExtArgs>
    detalle_orden?: boolean | ordenes_servicio$detalle_ordenArgs<ExtArgs>
    facturas?: boolean | ordenes_servicio$facturasArgs<ExtArgs>
    _count?: boolean | Ordenes_servicioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ordenes_servicio"]>

  export type ordenes_servicioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_orden?: boolean
    id_vehiculo?: boolean
    id_empleado?: boolean
    fecha_entrada?: boolean
    fecha_salida?: boolean
    observaciones?: boolean
    estado?: boolean
    kilometraje?: boolean
    created_at?: boolean
    vehiculo?: boolean | vehiculosDefaultArgs<ExtArgs>
    empleado?: boolean | ordenes_servicio$empleadoArgs<ExtArgs>
  }, ExtArgs["result"]["ordenes_servicio"]>

  export type ordenes_servicioSelectScalar = {
    id_orden?: boolean
    id_vehiculo?: boolean
    id_empleado?: boolean
    fecha_entrada?: boolean
    fecha_salida?: boolean
    observaciones?: boolean
    estado?: boolean
    kilometraje?: boolean
    created_at?: boolean
  }

  export type ordenes_servicioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehiculo?: boolean | vehiculosDefaultArgs<ExtArgs>
    empleado?: boolean | ordenes_servicio$empleadoArgs<ExtArgs>
    detalle_orden?: boolean | ordenes_servicio$detalle_ordenArgs<ExtArgs>
    facturas?: boolean | ordenes_servicio$facturasArgs<ExtArgs>
    _count?: boolean | Ordenes_servicioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ordenes_servicioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehiculo?: boolean | vehiculosDefaultArgs<ExtArgs>
    empleado?: boolean | ordenes_servicio$empleadoArgs<ExtArgs>
  }

  export type $ordenes_servicioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ordenes_servicio"
    objects: {
      vehiculo: Prisma.$vehiculosPayload<ExtArgs>
      empleado: Prisma.$empleadosPayload<ExtArgs> | null
      detalle_orden: Prisma.$detalle_ordenPayload<ExtArgs>[]
      facturas: Prisma.$facturasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_orden: number
      id_vehiculo: number
      id_empleado: number | null
      fecha_entrada: Date
      fecha_salida: Date | null
      observaciones: string | null
      estado: string
      kilometraje: number | null
      created_at: Date | null
    }, ExtArgs["result"]["ordenes_servicio"]>
    composites: {}
  }

  type ordenes_servicioGetPayload<S extends boolean | null | undefined | ordenes_servicioDefaultArgs> = $Result.GetResult<Prisma.$ordenes_servicioPayload, S>

  type ordenes_servicioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ordenes_servicioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Ordenes_servicioCountAggregateInputType | true
    }

  export interface ordenes_servicioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ordenes_servicio'], meta: { name: 'ordenes_servicio' } }
    /**
     * Find zero or one Ordenes_servicio that matches the filter.
     * @param {ordenes_servicioFindUniqueArgs} args - Arguments to find a Ordenes_servicio
     * @example
     * // Get one Ordenes_servicio
     * const ordenes_servicio = await prisma.ordenes_servicio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ordenes_servicioFindUniqueArgs>(args: SelectSubset<T, ordenes_servicioFindUniqueArgs<ExtArgs>>): Prisma__ordenes_servicioClient<$Result.GetResult<Prisma.$ordenes_servicioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ordenes_servicio that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ordenes_servicioFindUniqueOrThrowArgs} args - Arguments to find a Ordenes_servicio
     * @example
     * // Get one Ordenes_servicio
     * const ordenes_servicio = await prisma.ordenes_servicio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ordenes_servicioFindUniqueOrThrowArgs>(args: SelectSubset<T, ordenes_servicioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ordenes_servicioClient<$Result.GetResult<Prisma.$ordenes_servicioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ordenes_servicio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordenes_servicioFindFirstArgs} args - Arguments to find a Ordenes_servicio
     * @example
     * // Get one Ordenes_servicio
     * const ordenes_servicio = await prisma.ordenes_servicio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ordenes_servicioFindFirstArgs>(args?: SelectSubset<T, ordenes_servicioFindFirstArgs<ExtArgs>>): Prisma__ordenes_servicioClient<$Result.GetResult<Prisma.$ordenes_servicioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ordenes_servicio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordenes_servicioFindFirstOrThrowArgs} args - Arguments to find a Ordenes_servicio
     * @example
     * // Get one Ordenes_servicio
     * const ordenes_servicio = await prisma.ordenes_servicio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ordenes_servicioFindFirstOrThrowArgs>(args?: SelectSubset<T, ordenes_servicioFindFirstOrThrowArgs<ExtArgs>>): Prisma__ordenes_servicioClient<$Result.GetResult<Prisma.$ordenes_servicioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ordenes_servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordenes_servicioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ordenes_servicios
     * const ordenes_servicios = await prisma.ordenes_servicio.findMany()
     * 
     * // Get first 10 Ordenes_servicios
     * const ordenes_servicios = await prisma.ordenes_servicio.findMany({ take: 10 })
     * 
     * // Only select the `id_orden`
     * const ordenes_servicioWithId_ordenOnly = await prisma.ordenes_servicio.findMany({ select: { id_orden: true } })
     * 
     */
    findMany<T extends ordenes_servicioFindManyArgs>(args?: SelectSubset<T, ordenes_servicioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordenes_servicioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ordenes_servicio.
     * @param {ordenes_servicioCreateArgs} args - Arguments to create a Ordenes_servicio.
     * @example
     * // Create one Ordenes_servicio
     * const Ordenes_servicio = await prisma.ordenes_servicio.create({
     *   data: {
     *     // ... data to create a Ordenes_servicio
     *   }
     * })
     * 
     */
    create<T extends ordenes_servicioCreateArgs>(args: SelectSubset<T, ordenes_servicioCreateArgs<ExtArgs>>): Prisma__ordenes_servicioClient<$Result.GetResult<Prisma.$ordenes_servicioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ordenes_servicios.
     * @param {ordenes_servicioCreateManyArgs} args - Arguments to create many Ordenes_servicios.
     * @example
     * // Create many Ordenes_servicios
     * const ordenes_servicio = await prisma.ordenes_servicio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ordenes_servicioCreateManyArgs>(args?: SelectSubset<T, ordenes_servicioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ordenes_servicios and returns the data saved in the database.
     * @param {ordenes_servicioCreateManyAndReturnArgs} args - Arguments to create many Ordenes_servicios.
     * @example
     * // Create many Ordenes_servicios
     * const ordenes_servicio = await prisma.ordenes_servicio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ordenes_servicios and only return the `id_orden`
     * const ordenes_servicioWithId_ordenOnly = await prisma.ordenes_servicio.createManyAndReturn({ 
     *   select: { id_orden: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ordenes_servicioCreateManyAndReturnArgs>(args?: SelectSubset<T, ordenes_servicioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordenes_servicioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ordenes_servicio.
     * @param {ordenes_servicioDeleteArgs} args - Arguments to delete one Ordenes_servicio.
     * @example
     * // Delete one Ordenes_servicio
     * const Ordenes_servicio = await prisma.ordenes_servicio.delete({
     *   where: {
     *     // ... filter to delete one Ordenes_servicio
     *   }
     * })
     * 
     */
    delete<T extends ordenes_servicioDeleteArgs>(args: SelectSubset<T, ordenes_servicioDeleteArgs<ExtArgs>>): Prisma__ordenes_servicioClient<$Result.GetResult<Prisma.$ordenes_servicioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ordenes_servicio.
     * @param {ordenes_servicioUpdateArgs} args - Arguments to update one Ordenes_servicio.
     * @example
     * // Update one Ordenes_servicio
     * const ordenes_servicio = await prisma.ordenes_servicio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ordenes_servicioUpdateArgs>(args: SelectSubset<T, ordenes_servicioUpdateArgs<ExtArgs>>): Prisma__ordenes_servicioClient<$Result.GetResult<Prisma.$ordenes_servicioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ordenes_servicios.
     * @param {ordenes_servicioDeleteManyArgs} args - Arguments to filter Ordenes_servicios to delete.
     * @example
     * // Delete a few Ordenes_servicios
     * const { count } = await prisma.ordenes_servicio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ordenes_servicioDeleteManyArgs>(args?: SelectSubset<T, ordenes_servicioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ordenes_servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordenes_servicioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ordenes_servicios
     * const ordenes_servicio = await prisma.ordenes_servicio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ordenes_servicioUpdateManyArgs>(args: SelectSubset<T, ordenes_servicioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ordenes_servicio.
     * @param {ordenes_servicioUpsertArgs} args - Arguments to update or create a Ordenes_servicio.
     * @example
     * // Update or create a Ordenes_servicio
     * const ordenes_servicio = await prisma.ordenes_servicio.upsert({
     *   create: {
     *     // ... data to create a Ordenes_servicio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ordenes_servicio we want to update
     *   }
     * })
     */
    upsert<T extends ordenes_servicioUpsertArgs>(args: SelectSubset<T, ordenes_servicioUpsertArgs<ExtArgs>>): Prisma__ordenes_servicioClient<$Result.GetResult<Prisma.$ordenes_servicioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ordenes_servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordenes_servicioCountArgs} args - Arguments to filter Ordenes_servicios to count.
     * @example
     * // Count the number of Ordenes_servicios
     * const count = await prisma.ordenes_servicio.count({
     *   where: {
     *     // ... the filter for the Ordenes_servicios we want to count
     *   }
     * })
    **/
    count<T extends ordenes_servicioCountArgs>(
      args?: Subset<T, ordenes_servicioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ordenes_servicioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ordenes_servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ordenes_servicioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ordenes_servicioAggregateArgs>(args: Subset<T, Ordenes_servicioAggregateArgs>): Prisma.PrismaPromise<GetOrdenes_servicioAggregateType<T>>

    /**
     * Group by Ordenes_servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordenes_servicioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ordenes_servicioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ordenes_servicioGroupByArgs['orderBy'] }
        : { orderBy?: ordenes_servicioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ordenes_servicioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdenes_servicioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ordenes_servicio model
   */
  readonly fields: ordenes_servicioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ordenes_servicio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ordenes_servicioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehiculo<T extends vehiculosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, vehiculosDefaultArgs<ExtArgs>>): Prisma__vehiculosClient<$Result.GetResult<Prisma.$vehiculosPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    empleado<T extends ordenes_servicio$empleadoArgs<ExtArgs> = {}>(args?: Subset<T, ordenes_servicio$empleadoArgs<ExtArgs>>): Prisma__empleadosClient<$Result.GetResult<Prisma.$empleadosPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    detalle_orden<T extends ordenes_servicio$detalle_ordenArgs<ExtArgs> = {}>(args?: Subset<T, ordenes_servicio$detalle_ordenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detalle_ordenPayload<ExtArgs>, T, "findMany"> | Null>
    facturas<T extends ordenes_servicio$facturasArgs<ExtArgs> = {}>(args?: Subset<T, ordenes_servicio$facturasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ordenes_servicio model
   */ 
  interface ordenes_servicioFieldRefs {
    readonly id_orden: FieldRef<"ordenes_servicio", 'Int'>
    readonly id_vehiculo: FieldRef<"ordenes_servicio", 'Int'>
    readonly id_empleado: FieldRef<"ordenes_servicio", 'Int'>
    readonly fecha_entrada: FieldRef<"ordenes_servicio", 'DateTime'>
    readonly fecha_salida: FieldRef<"ordenes_servicio", 'DateTime'>
    readonly observaciones: FieldRef<"ordenes_servicio", 'String'>
    readonly estado: FieldRef<"ordenes_servicio", 'String'>
    readonly kilometraje: FieldRef<"ordenes_servicio", 'Int'>
    readonly created_at: FieldRef<"ordenes_servicio", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ordenes_servicio findUnique
   */
  export type ordenes_servicioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_servicio
     */
    select?: ordenes_servicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordenes_servicioInclude<ExtArgs> | null
    /**
     * Filter, which ordenes_servicio to fetch.
     */
    where: ordenes_servicioWhereUniqueInput
  }

  /**
   * ordenes_servicio findUniqueOrThrow
   */
  export type ordenes_servicioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_servicio
     */
    select?: ordenes_servicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordenes_servicioInclude<ExtArgs> | null
    /**
     * Filter, which ordenes_servicio to fetch.
     */
    where: ordenes_servicioWhereUniqueInput
  }

  /**
   * ordenes_servicio findFirst
   */
  export type ordenes_servicioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_servicio
     */
    select?: ordenes_servicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordenes_servicioInclude<ExtArgs> | null
    /**
     * Filter, which ordenes_servicio to fetch.
     */
    where?: ordenes_servicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ordenes_servicios to fetch.
     */
    orderBy?: ordenes_servicioOrderByWithRelationInput | ordenes_servicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ordenes_servicios.
     */
    cursor?: ordenes_servicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ordenes_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ordenes_servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ordenes_servicios.
     */
    distinct?: Ordenes_servicioScalarFieldEnum | Ordenes_servicioScalarFieldEnum[]
  }

  /**
   * ordenes_servicio findFirstOrThrow
   */
  export type ordenes_servicioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_servicio
     */
    select?: ordenes_servicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordenes_servicioInclude<ExtArgs> | null
    /**
     * Filter, which ordenes_servicio to fetch.
     */
    where?: ordenes_servicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ordenes_servicios to fetch.
     */
    orderBy?: ordenes_servicioOrderByWithRelationInput | ordenes_servicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ordenes_servicios.
     */
    cursor?: ordenes_servicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ordenes_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ordenes_servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ordenes_servicios.
     */
    distinct?: Ordenes_servicioScalarFieldEnum | Ordenes_servicioScalarFieldEnum[]
  }

  /**
   * ordenes_servicio findMany
   */
  export type ordenes_servicioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_servicio
     */
    select?: ordenes_servicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordenes_servicioInclude<ExtArgs> | null
    /**
     * Filter, which ordenes_servicios to fetch.
     */
    where?: ordenes_servicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ordenes_servicios to fetch.
     */
    orderBy?: ordenes_servicioOrderByWithRelationInput | ordenes_servicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ordenes_servicios.
     */
    cursor?: ordenes_servicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ordenes_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ordenes_servicios.
     */
    skip?: number
    distinct?: Ordenes_servicioScalarFieldEnum | Ordenes_servicioScalarFieldEnum[]
  }

  /**
   * ordenes_servicio create
   */
  export type ordenes_servicioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_servicio
     */
    select?: ordenes_servicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordenes_servicioInclude<ExtArgs> | null
    /**
     * The data needed to create a ordenes_servicio.
     */
    data: XOR<ordenes_servicioCreateInput, ordenes_servicioUncheckedCreateInput>
  }

  /**
   * ordenes_servicio createMany
   */
  export type ordenes_servicioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ordenes_servicios.
     */
    data: ordenes_servicioCreateManyInput | ordenes_servicioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ordenes_servicio createManyAndReturn
   */
  export type ordenes_servicioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_servicio
     */
    select?: ordenes_servicioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ordenes_servicios.
     */
    data: ordenes_servicioCreateManyInput | ordenes_servicioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordenes_servicioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ordenes_servicio update
   */
  export type ordenes_servicioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_servicio
     */
    select?: ordenes_servicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordenes_servicioInclude<ExtArgs> | null
    /**
     * The data needed to update a ordenes_servicio.
     */
    data: XOR<ordenes_servicioUpdateInput, ordenes_servicioUncheckedUpdateInput>
    /**
     * Choose, which ordenes_servicio to update.
     */
    where: ordenes_servicioWhereUniqueInput
  }

  /**
   * ordenes_servicio updateMany
   */
  export type ordenes_servicioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ordenes_servicios.
     */
    data: XOR<ordenes_servicioUpdateManyMutationInput, ordenes_servicioUncheckedUpdateManyInput>
    /**
     * Filter which ordenes_servicios to update
     */
    where?: ordenes_servicioWhereInput
  }

  /**
   * ordenes_servicio upsert
   */
  export type ordenes_servicioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_servicio
     */
    select?: ordenes_servicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordenes_servicioInclude<ExtArgs> | null
    /**
     * The filter to search for the ordenes_servicio to update in case it exists.
     */
    where: ordenes_servicioWhereUniqueInput
    /**
     * In case the ordenes_servicio found by the `where` argument doesn't exist, create a new ordenes_servicio with this data.
     */
    create: XOR<ordenes_servicioCreateInput, ordenes_servicioUncheckedCreateInput>
    /**
     * In case the ordenes_servicio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ordenes_servicioUpdateInput, ordenes_servicioUncheckedUpdateInput>
  }

  /**
   * ordenes_servicio delete
   */
  export type ordenes_servicioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_servicio
     */
    select?: ordenes_servicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordenes_servicioInclude<ExtArgs> | null
    /**
     * Filter which ordenes_servicio to delete.
     */
    where: ordenes_servicioWhereUniqueInput
  }

  /**
   * ordenes_servicio deleteMany
   */
  export type ordenes_servicioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ordenes_servicios to delete
     */
    where?: ordenes_servicioWhereInput
  }

  /**
   * ordenes_servicio.empleado
   */
  export type ordenes_servicio$empleadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleados
     */
    select?: empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empleadosInclude<ExtArgs> | null
    where?: empleadosWhereInput
  }

  /**
   * ordenes_servicio.detalle_orden
   */
  export type ordenes_servicio$detalle_ordenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden
     */
    select?: detalle_ordenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_ordenInclude<ExtArgs> | null
    where?: detalle_ordenWhereInput
    orderBy?: detalle_ordenOrderByWithRelationInput | detalle_ordenOrderByWithRelationInput[]
    cursor?: detalle_ordenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detalle_ordenScalarFieldEnum | Detalle_ordenScalarFieldEnum[]
  }

  /**
   * ordenes_servicio.facturas
   */
  export type ordenes_servicio$facturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
    where?: facturasWhereInput
    orderBy?: facturasOrderByWithRelationInput | facturasOrderByWithRelationInput[]
    cursor?: facturasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacturasScalarFieldEnum | FacturasScalarFieldEnum[]
  }

  /**
   * ordenes_servicio without action
   */
  export type ordenes_servicioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_servicio
     */
    select?: ordenes_servicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordenes_servicioInclude<ExtArgs> | null
  }


  /**
   * Model detalle_orden
   */

  export type AggregateDetalle_orden = {
    _count: Detalle_ordenCountAggregateOutputType | null
    _avg: Detalle_ordenAvgAggregateOutputType | null
    _sum: Detalle_ordenSumAggregateOutputType | null
    _min: Detalle_ordenMinAggregateOutputType | null
    _max: Detalle_ordenMaxAggregateOutputType | null
  }

  export type Detalle_ordenAvgAggregateOutputType = {
    id_detalle: number | null
    id_orden: number | null
    id_servicio: number | null
    cantidad: number | null
    precio_unit: Decimal | null
    subtotal: Decimal | null
  }

  export type Detalle_ordenSumAggregateOutputType = {
    id_detalle: number | null
    id_orden: number | null
    id_servicio: number | null
    cantidad: number | null
    precio_unit: Decimal | null
    subtotal: Decimal | null
  }

  export type Detalle_ordenMinAggregateOutputType = {
    id_detalle: number | null
    id_orden: number | null
    id_servicio: number | null
    cantidad: number | null
    precio_unit: Decimal | null
    subtotal: Decimal | null
    created_at: Date | null
  }

  export type Detalle_ordenMaxAggregateOutputType = {
    id_detalle: number | null
    id_orden: number | null
    id_servicio: number | null
    cantidad: number | null
    precio_unit: Decimal | null
    subtotal: Decimal | null
    created_at: Date | null
  }

  export type Detalle_ordenCountAggregateOutputType = {
    id_detalle: number
    id_orden: number
    id_servicio: number
    cantidad: number
    precio_unit: number
    subtotal: number
    created_at: number
    _all: number
  }


  export type Detalle_ordenAvgAggregateInputType = {
    id_detalle?: true
    id_orden?: true
    id_servicio?: true
    cantidad?: true
    precio_unit?: true
    subtotal?: true
  }

  export type Detalle_ordenSumAggregateInputType = {
    id_detalle?: true
    id_orden?: true
    id_servicio?: true
    cantidad?: true
    precio_unit?: true
    subtotal?: true
  }

  export type Detalle_ordenMinAggregateInputType = {
    id_detalle?: true
    id_orden?: true
    id_servicio?: true
    cantidad?: true
    precio_unit?: true
    subtotal?: true
    created_at?: true
  }

  export type Detalle_ordenMaxAggregateInputType = {
    id_detalle?: true
    id_orden?: true
    id_servicio?: true
    cantidad?: true
    precio_unit?: true
    subtotal?: true
    created_at?: true
  }

  export type Detalle_ordenCountAggregateInputType = {
    id_detalle?: true
    id_orden?: true
    id_servicio?: true
    cantidad?: true
    precio_unit?: true
    subtotal?: true
    created_at?: true
    _all?: true
  }

  export type Detalle_ordenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which detalle_orden to aggregate.
     */
    where?: detalle_ordenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_ordens to fetch.
     */
    orderBy?: detalle_ordenOrderByWithRelationInput | detalle_ordenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: detalle_ordenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_ordens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_ordens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned detalle_ordens
    **/
    _count?: true | Detalle_ordenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Detalle_ordenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Detalle_ordenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Detalle_ordenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Detalle_ordenMaxAggregateInputType
  }

  export type GetDetalle_ordenAggregateType<T extends Detalle_ordenAggregateArgs> = {
        [P in keyof T & keyof AggregateDetalle_orden]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetalle_orden[P]>
      : GetScalarType<T[P], AggregateDetalle_orden[P]>
  }




  export type detalle_ordenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detalle_ordenWhereInput
    orderBy?: detalle_ordenOrderByWithAggregationInput | detalle_ordenOrderByWithAggregationInput[]
    by: Detalle_ordenScalarFieldEnum[] | Detalle_ordenScalarFieldEnum
    having?: detalle_ordenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Detalle_ordenCountAggregateInputType | true
    _avg?: Detalle_ordenAvgAggregateInputType
    _sum?: Detalle_ordenSumAggregateInputType
    _min?: Detalle_ordenMinAggregateInputType
    _max?: Detalle_ordenMaxAggregateInputType
  }

  export type Detalle_ordenGroupByOutputType = {
    id_detalle: number
    id_orden: number
    id_servicio: number
    cantidad: number
    precio_unit: Decimal
    subtotal: Decimal
    created_at: Date | null
    _count: Detalle_ordenCountAggregateOutputType | null
    _avg: Detalle_ordenAvgAggregateOutputType | null
    _sum: Detalle_ordenSumAggregateOutputType | null
    _min: Detalle_ordenMinAggregateOutputType | null
    _max: Detalle_ordenMaxAggregateOutputType | null
  }

  type GetDetalle_ordenGroupByPayload<T extends detalle_ordenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Detalle_ordenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Detalle_ordenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Detalle_ordenGroupByOutputType[P]>
            : GetScalarType<T[P], Detalle_ordenGroupByOutputType[P]>
        }
      >
    >


  export type detalle_ordenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_detalle?: boolean
    id_orden?: boolean
    id_servicio?: boolean
    cantidad?: boolean
    precio_unit?: boolean
    subtotal?: boolean
    created_at?: boolean
    orden?: boolean | ordenes_servicioDefaultArgs<ExtArgs>
    servicio?: boolean | serviciosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detalle_orden"]>

  export type detalle_ordenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_detalle?: boolean
    id_orden?: boolean
    id_servicio?: boolean
    cantidad?: boolean
    precio_unit?: boolean
    subtotal?: boolean
    created_at?: boolean
    orden?: boolean | ordenes_servicioDefaultArgs<ExtArgs>
    servicio?: boolean | serviciosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detalle_orden"]>

  export type detalle_ordenSelectScalar = {
    id_detalle?: boolean
    id_orden?: boolean
    id_servicio?: boolean
    cantidad?: boolean
    precio_unit?: boolean
    subtotal?: boolean
    created_at?: boolean
  }

  export type detalle_ordenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orden?: boolean | ordenes_servicioDefaultArgs<ExtArgs>
    servicio?: boolean | serviciosDefaultArgs<ExtArgs>
  }
  export type detalle_ordenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orden?: boolean | ordenes_servicioDefaultArgs<ExtArgs>
    servicio?: boolean | serviciosDefaultArgs<ExtArgs>
  }

  export type $detalle_ordenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "detalle_orden"
    objects: {
      orden: Prisma.$ordenes_servicioPayload<ExtArgs>
      servicio: Prisma.$serviciosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_detalle: number
      id_orden: number
      id_servicio: number
      cantidad: number
      precio_unit: Prisma.Decimal
      subtotal: Prisma.Decimal
      created_at: Date | null
    }, ExtArgs["result"]["detalle_orden"]>
    composites: {}
  }

  type detalle_ordenGetPayload<S extends boolean | null | undefined | detalle_ordenDefaultArgs> = $Result.GetResult<Prisma.$detalle_ordenPayload, S>

  type detalle_ordenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<detalle_ordenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Detalle_ordenCountAggregateInputType | true
    }

  export interface detalle_ordenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['detalle_orden'], meta: { name: 'detalle_orden' } }
    /**
     * Find zero or one Detalle_orden that matches the filter.
     * @param {detalle_ordenFindUniqueArgs} args - Arguments to find a Detalle_orden
     * @example
     * // Get one Detalle_orden
     * const detalle_orden = await prisma.detalle_orden.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends detalle_ordenFindUniqueArgs>(args: SelectSubset<T, detalle_ordenFindUniqueArgs<ExtArgs>>): Prisma__detalle_ordenClient<$Result.GetResult<Prisma.$detalle_ordenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Detalle_orden that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {detalle_ordenFindUniqueOrThrowArgs} args - Arguments to find a Detalle_orden
     * @example
     * // Get one Detalle_orden
     * const detalle_orden = await prisma.detalle_orden.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends detalle_ordenFindUniqueOrThrowArgs>(args: SelectSubset<T, detalle_ordenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__detalle_ordenClient<$Result.GetResult<Prisma.$detalle_ordenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Detalle_orden that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_ordenFindFirstArgs} args - Arguments to find a Detalle_orden
     * @example
     * // Get one Detalle_orden
     * const detalle_orden = await prisma.detalle_orden.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends detalle_ordenFindFirstArgs>(args?: SelectSubset<T, detalle_ordenFindFirstArgs<ExtArgs>>): Prisma__detalle_ordenClient<$Result.GetResult<Prisma.$detalle_ordenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Detalle_orden that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_ordenFindFirstOrThrowArgs} args - Arguments to find a Detalle_orden
     * @example
     * // Get one Detalle_orden
     * const detalle_orden = await prisma.detalle_orden.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends detalle_ordenFindFirstOrThrowArgs>(args?: SelectSubset<T, detalle_ordenFindFirstOrThrowArgs<ExtArgs>>): Prisma__detalle_ordenClient<$Result.GetResult<Prisma.$detalle_ordenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Detalle_ordens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_ordenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Detalle_ordens
     * const detalle_ordens = await prisma.detalle_orden.findMany()
     * 
     * // Get first 10 Detalle_ordens
     * const detalle_ordens = await prisma.detalle_orden.findMany({ take: 10 })
     * 
     * // Only select the `id_detalle`
     * const detalle_ordenWithId_detalleOnly = await prisma.detalle_orden.findMany({ select: { id_detalle: true } })
     * 
     */
    findMany<T extends detalle_ordenFindManyArgs>(args?: SelectSubset<T, detalle_ordenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detalle_ordenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Detalle_orden.
     * @param {detalle_ordenCreateArgs} args - Arguments to create a Detalle_orden.
     * @example
     * // Create one Detalle_orden
     * const Detalle_orden = await prisma.detalle_orden.create({
     *   data: {
     *     // ... data to create a Detalle_orden
     *   }
     * })
     * 
     */
    create<T extends detalle_ordenCreateArgs>(args: SelectSubset<T, detalle_ordenCreateArgs<ExtArgs>>): Prisma__detalle_ordenClient<$Result.GetResult<Prisma.$detalle_ordenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Detalle_ordens.
     * @param {detalle_ordenCreateManyArgs} args - Arguments to create many Detalle_ordens.
     * @example
     * // Create many Detalle_ordens
     * const detalle_orden = await prisma.detalle_orden.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends detalle_ordenCreateManyArgs>(args?: SelectSubset<T, detalle_ordenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Detalle_ordens and returns the data saved in the database.
     * @param {detalle_ordenCreateManyAndReturnArgs} args - Arguments to create many Detalle_ordens.
     * @example
     * // Create many Detalle_ordens
     * const detalle_orden = await prisma.detalle_orden.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Detalle_ordens and only return the `id_detalle`
     * const detalle_ordenWithId_detalleOnly = await prisma.detalle_orden.createManyAndReturn({ 
     *   select: { id_detalle: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends detalle_ordenCreateManyAndReturnArgs>(args?: SelectSubset<T, detalle_ordenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detalle_ordenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Detalle_orden.
     * @param {detalle_ordenDeleteArgs} args - Arguments to delete one Detalle_orden.
     * @example
     * // Delete one Detalle_orden
     * const Detalle_orden = await prisma.detalle_orden.delete({
     *   where: {
     *     // ... filter to delete one Detalle_orden
     *   }
     * })
     * 
     */
    delete<T extends detalle_ordenDeleteArgs>(args: SelectSubset<T, detalle_ordenDeleteArgs<ExtArgs>>): Prisma__detalle_ordenClient<$Result.GetResult<Prisma.$detalle_ordenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Detalle_orden.
     * @param {detalle_ordenUpdateArgs} args - Arguments to update one Detalle_orden.
     * @example
     * // Update one Detalle_orden
     * const detalle_orden = await prisma.detalle_orden.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends detalle_ordenUpdateArgs>(args: SelectSubset<T, detalle_ordenUpdateArgs<ExtArgs>>): Prisma__detalle_ordenClient<$Result.GetResult<Prisma.$detalle_ordenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Detalle_ordens.
     * @param {detalle_ordenDeleteManyArgs} args - Arguments to filter Detalle_ordens to delete.
     * @example
     * // Delete a few Detalle_ordens
     * const { count } = await prisma.detalle_orden.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends detalle_ordenDeleteManyArgs>(args?: SelectSubset<T, detalle_ordenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Detalle_ordens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_ordenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Detalle_ordens
     * const detalle_orden = await prisma.detalle_orden.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends detalle_ordenUpdateManyArgs>(args: SelectSubset<T, detalle_ordenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Detalle_orden.
     * @param {detalle_ordenUpsertArgs} args - Arguments to update or create a Detalle_orden.
     * @example
     * // Update or create a Detalle_orden
     * const detalle_orden = await prisma.detalle_orden.upsert({
     *   create: {
     *     // ... data to create a Detalle_orden
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Detalle_orden we want to update
     *   }
     * })
     */
    upsert<T extends detalle_ordenUpsertArgs>(args: SelectSubset<T, detalle_ordenUpsertArgs<ExtArgs>>): Prisma__detalle_ordenClient<$Result.GetResult<Prisma.$detalle_ordenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Detalle_ordens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_ordenCountArgs} args - Arguments to filter Detalle_ordens to count.
     * @example
     * // Count the number of Detalle_ordens
     * const count = await prisma.detalle_orden.count({
     *   where: {
     *     // ... the filter for the Detalle_ordens we want to count
     *   }
     * })
    **/
    count<T extends detalle_ordenCountArgs>(
      args?: Subset<T, detalle_ordenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Detalle_ordenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Detalle_orden.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Detalle_ordenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Detalle_ordenAggregateArgs>(args: Subset<T, Detalle_ordenAggregateArgs>): Prisma.PrismaPromise<GetDetalle_ordenAggregateType<T>>

    /**
     * Group by Detalle_orden.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_ordenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends detalle_ordenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: detalle_ordenGroupByArgs['orderBy'] }
        : { orderBy?: detalle_ordenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, detalle_ordenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetalle_ordenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the detalle_orden model
   */
  readonly fields: detalle_ordenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for detalle_orden.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__detalle_ordenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orden<T extends ordenes_servicioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ordenes_servicioDefaultArgs<ExtArgs>>): Prisma__ordenes_servicioClient<$Result.GetResult<Prisma.$ordenes_servicioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    servicio<T extends serviciosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, serviciosDefaultArgs<ExtArgs>>): Prisma__serviciosClient<$Result.GetResult<Prisma.$serviciosPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the detalle_orden model
   */ 
  interface detalle_ordenFieldRefs {
    readonly id_detalle: FieldRef<"detalle_orden", 'Int'>
    readonly id_orden: FieldRef<"detalle_orden", 'Int'>
    readonly id_servicio: FieldRef<"detalle_orden", 'Int'>
    readonly cantidad: FieldRef<"detalle_orden", 'Int'>
    readonly precio_unit: FieldRef<"detalle_orden", 'Decimal'>
    readonly subtotal: FieldRef<"detalle_orden", 'Decimal'>
    readonly created_at: FieldRef<"detalle_orden", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * detalle_orden findUnique
   */
  export type detalle_ordenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden
     */
    select?: detalle_ordenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_ordenInclude<ExtArgs> | null
    /**
     * Filter, which detalle_orden to fetch.
     */
    where: detalle_ordenWhereUniqueInput
  }

  /**
   * detalle_orden findUniqueOrThrow
   */
  export type detalle_ordenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden
     */
    select?: detalle_ordenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_ordenInclude<ExtArgs> | null
    /**
     * Filter, which detalle_orden to fetch.
     */
    where: detalle_ordenWhereUniqueInput
  }

  /**
   * detalle_orden findFirst
   */
  export type detalle_ordenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden
     */
    select?: detalle_ordenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_ordenInclude<ExtArgs> | null
    /**
     * Filter, which detalle_orden to fetch.
     */
    where?: detalle_ordenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_ordens to fetch.
     */
    orderBy?: detalle_ordenOrderByWithRelationInput | detalle_ordenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detalle_ordens.
     */
    cursor?: detalle_ordenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_ordens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_ordens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detalle_ordens.
     */
    distinct?: Detalle_ordenScalarFieldEnum | Detalle_ordenScalarFieldEnum[]
  }

  /**
   * detalle_orden findFirstOrThrow
   */
  export type detalle_ordenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden
     */
    select?: detalle_ordenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_ordenInclude<ExtArgs> | null
    /**
     * Filter, which detalle_orden to fetch.
     */
    where?: detalle_ordenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_ordens to fetch.
     */
    orderBy?: detalle_ordenOrderByWithRelationInput | detalle_ordenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detalle_ordens.
     */
    cursor?: detalle_ordenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_ordens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_ordens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detalle_ordens.
     */
    distinct?: Detalle_ordenScalarFieldEnum | Detalle_ordenScalarFieldEnum[]
  }

  /**
   * detalle_orden findMany
   */
  export type detalle_ordenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden
     */
    select?: detalle_ordenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_ordenInclude<ExtArgs> | null
    /**
     * Filter, which detalle_ordens to fetch.
     */
    where?: detalle_ordenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_ordens to fetch.
     */
    orderBy?: detalle_ordenOrderByWithRelationInput | detalle_ordenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing detalle_ordens.
     */
    cursor?: detalle_ordenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_ordens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_ordens.
     */
    skip?: number
    distinct?: Detalle_ordenScalarFieldEnum | Detalle_ordenScalarFieldEnum[]
  }

  /**
   * detalle_orden create
   */
  export type detalle_ordenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden
     */
    select?: detalle_ordenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_ordenInclude<ExtArgs> | null
    /**
     * The data needed to create a detalle_orden.
     */
    data: XOR<detalle_ordenCreateInput, detalle_ordenUncheckedCreateInput>
  }

  /**
   * detalle_orden createMany
   */
  export type detalle_ordenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many detalle_ordens.
     */
    data: detalle_ordenCreateManyInput | detalle_ordenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * detalle_orden createManyAndReturn
   */
  export type detalle_ordenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden
     */
    select?: detalle_ordenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many detalle_ordens.
     */
    data: detalle_ordenCreateManyInput | detalle_ordenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_ordenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * detalle_orden update
   */
  export type detalle_ordenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden
     */
    select?: detalle_ordenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_ordenInclude<ExtArgs> | null
    /**
     * The data needed to update a detalle_orden.
     */
    data: XOR<detalle_ordenUpdateInput, detalle_ordenUncheckedUpdateInput>
    /**
     * Choose, which detalle_orden to update.
     */
    where: detalle_ordenWhereUniqueInput
  }

  /**
   * detalle_orden updateMany
   */
  export type detalle_ordenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update detalle_ordens.
     */
    data: XOR<detalle_ordenUpdateManyMutationInput, detalle_ordenUncheckedUpdateManyInput>
    /**
     * Filter which detalle_ordens to update
     */
    where?: detalle_ordenWhereInput
  }

  /**
   * detalle_orden upsert
   */
  export type detalle_ordenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden
     */
    select?: detalle_ordenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_ordenInclude<ExtArgs> | null
    /**
     * The filter to search for the detalle_orden to update in case it exists.
     */
    where: detalle_ordenWhereUniqueInput
    /**
     * In case the detalle_orden found by the `where` argument doesn't exist, create a new detalle_orden with this data.
     */
    create: XOR<detalle_ordenCreateInput, detalle_ordenUncheckedCreateInput>
    /**
     * In case the detalle_orden was found with the provided `where` argument, update it with this data.
     */
    update: XOR<detalle_ordenUpdateInput, detalle_ordenUncheckedUpdateInput>
  }

  /**
   * detalle_orden delete
   */
  export type detalle_ordenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden
     */
    select?: detalle_ordenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_ordenInclude<ExtArgs> | null
    /**
     * Filter which detalle_orden to delete.
     */
    where: detalle_ordenWhereUniqueInput
  }

  /**
   * detalle_orden deleteMany
   */
  export type detalle_ordenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which detalle_ordens to delete
     */
    where?: detalle_ordenWhereInput
  }

  /**
   * detalle_orden without action
   */
  export type detalle_ordenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden
     */
    select?: detalle_ordenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_ordenInclude<ExtArgs> | null
  }


  /**
   * Model facturas
   */

  export type AggregateFacturas = {
    _count: FacturasCountAggregateOutputType | null
    _avg: FacturasAvgAggregateOutputType | null
    _sum: FacturasSumAggregateOutputType | null
    _min: FacturasMinAggregateOutputType | null
    _max: FacturasMaxAggregateOutputType | null
  }

  export type FacturasAvgAggregateOutputType = {
    id_factura: number | null
    id_orden: number | null
    subtotal: Decimal | null
    iva: Decimal | null
    total: Decimal | null
  }

  export type FacturasSumAggregateOutputType = {
    id_factura: number | null
    id_orden: number | null
    subtotal: Decimal | null
    iva: Decimal | null
    total: Decimal | null
  }

  export type FacturasMinAggregateOutputType = {
    id_factura: number | null
    id_orden: number | null
    fecha: Date | null
    subtotal: Decimal | null
    iva: Decimal | null
    total: Decimal | null
    metodo_pago: string | null
    created_at: Date | null
  }

  export type FacturasMaxAggregateOutputType = {
    id_factura: number | null
    id_orden: number | null
    fecha: Date | null
    subtotal: Decimal | null
    iva: Decimal | null
    total: Decimal | null
    metodo_pago: string | null
    created_at: Date | null
  }

  export type FacturasCountAggregateOutputType = {
    id_factura: number
    id_orden: number
    fecha: number
    subtotal: number
    iva: number
    total: number
    metodo_pago: number
    created_at: number
    _all: number
  }


  export type FacturasAvgAggregateInputType = {
    id_factura?: true
    id_orden?: true
    subtotal?: true
    iva?: true
    total?: true
  }

  export type FacturasSumAggregateInputType = {
    id_factura?: true
    id_orden?: true
    subtotal?: true
    iva?: true
    total?: true
  }

  export type FacturasMinAggregateInputType = {
    id_factura?: true
    id_orden?: true
    fecha?: true
    subtotal?: true
    iva?: true
    total?: true
    metodo_pago?: true
    created_at?: true
  }

  export type FacturasMaxAggregateInputType = {
    id_factura?: true
    id_orden?: true
    fecha?: true
    subtotal?: true
    iva?: true
    total?: true
    metodo_pago?: true
    created_at?: true
  }

  export type FacturasCountAggregateInputType = {
    id_factura?: true
    id_orden?: true
    fecha?: true
    subtotal?: true
    iva?: true
    total?: true
    metodo_pago?: true
    created_at?: true
    _all?: true
  }

  export type FacturasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which facturas to aggregate.
     */
    where?: facturasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of facturas to fetch.
     */
    orderBy?: facturasOrderByWithRelationInput | facturasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: facturasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` facturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned facturas
    **/
    _count?: true | FacturasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacturasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacturasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacturasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacturasMaxAggregateInputType
  }

  export type GetFacturasAggregateType<T extends FacturasAggregateArgs> = {
        [P in keyof T & keyof AggregateFacturas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacturas[P]>
      : GetScalarType<T[P], AggregateFacturas[P]>
  }




  export type facturasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: facturasWhereInput
    orderBy?: facturasOrderByWithAggregationInput | facturasOrderByWithAggregationInput[]
    by: FacturasScalarFieldEnum[] | FacturasScalarFieldEnum
    having?: facturasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacturasCountAggregateInputType | true
    _avg?: FacturasAvgAggregateInputType
    _sum?: FacturasSumAggregateInputType
    _min?: FacturasMinAggregateInputType
    _max?: FacturasMaxAggregateInputType
  }

  export type FacturasGroupByOutputType = {
    id_factura: number
    id_orden: number
    fecha: Date
    subtotal: Decimal
    iva: Decimal
    total: Decimal
    metodo_pago: string | null
    created_at: Date | null
    _count: FacturasCountAggregateOutputType | null
    _avg: FacturasAvgAggregateOutputType | null
    _sum: FacturasSumAggregateOutputType | null
    _min: FacturasMinAggregateOutputType | null
    _max: FacturasMaxAggregateOutputType | null
  }

  type GetFacturasGroupByPayload<T extends facturasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacturasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacturasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacturasGroupByOutputType[P]>
            : GetScalarType<T[P], FacturasGroupByOutputType[P]>
        }
      >
    >


  export type facturasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_factura?: boolean
    id_orden?: boolean
    fecha?: boolean
    subtotal?: boolean
    iva?: boolean
    total?: boolean
    metodo_pago?: boolean
    created_at?: boolean
    orden?: boolean | ordenes_servicioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facturas"]>

  export type facturasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_factura?: boolean
    id_orden?: boolean
    fecha?: boolean
    subtotal?: boolean
    iva?: boolean
    total?: boolean
    metodo_pago?: boolean
    created_at?: boolean
    orden?: boolean | ordenes_servicioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facturas"]>

  export type facturasSelectScalar = {
    id_factura?: boolean
    id_orden?: boolean
    fecha?: boolean
    subtotal?: boolean
    iva?: boolean
    total?: boolean
    metodo_pago?: boolean
    created_at?: boolean
  }

  export type facturasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orden?: boolean | ordenes_servicioDefaultArgs<ExtArgs>
  }
  export type facturasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orden?: boolean | ordenes_servicioDefaultArgs<ExtArgs>
  }

  export type $facturasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "facturas"
    objects: {
      orden: Prisma.$ordenes_servicioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_factura: number
      id_orden: number
      fecha: Date
      subtotal: Prisma.Decimal
      iva: Prisma.Decimal
      total: Prisma.Decimal
      metodo_pago: string | null
      created_at: Date | null
    }, ExtArgs["result"]["facturas"]>
    composites: {}
  }

  type facturasGetPayload<S extends boolean | null | undefined | facturasDefaultArgs> = $Result.GetResult<Prisma.$facturasPayload, S>

  type facturasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<facturasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FacturasCountAggregateInputType | true
    }

  export interface facturasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['facturas'], meta: { name: 'facturas' } }
    /**
     * Find zero or one Facturas that matches the filter.
     * @param {facturasFindUniqueArgs} args - Arguments to find a Facturas
     * @example
     * // Get one Facturas
     * const facturas = await prisma.facturas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends facturasFindUniqueArgs>(args: SelectSubset<T, facturasFindUniqueArgs<ExtArgs>>): Prisma__facturasClient<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Facturas that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {facturasFindUniqueOrThrowArgs} args - Arguments to find a Facturas
     * @example
     * // Get one Facturas
     * const facturas = await prisma.facturas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends facturasFindUniqueOrThrowArgs>(args: SelectSubset<T, facturasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__facturasClient<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Facturas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturasFindFirstArgs} args - Arguments to find a Facturas
     * @example
     * // Get one Facturas
     * const facturas = await prisma.facturas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends facturasFindFirstArgs>(args?: SelectSubset<T, facturasFindFirstArgs<ExtArgs>>): Prisma__facturasClient<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Facturas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturasFindFirstOrThrowArgs} args - Arguments to find a Facturas
     * @example
     * // Get one Facturas
     * const facturas = await prisma.facturas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends facturasFindFirstOrThrowArgs>(args?: SelectSubset<T, facturasFindFirstOrThrowArgs<ExtArgs>>): Prisma__facturasClient<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Facturas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Facturas
     * const facturas = await prisma.facturas.findMany()
     * 
     * // Get first 10 Facturas
     * const facturas = await prisma.facturas.findMany({ take: 10 })
     * 
     * // Only select the `id_factura`
     * const facturasWithId_facturaOnly = await prisma.facturas.findMany({ select: { id_factura: true } })
     * 
     */
    findMany<T extends facturasFindManyArgs>(args?: SelectSubset<T, facturasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Facturas.
     * @param {facturasCreateArgs} args - Arguments to create a Facturas.
     * @example
     * // Create one Facturas
     * const Facturas = await prisma.facturas.create({
     *   data: {
     *     // ... data to create a Facturas
     *   }
     * })
     * 
     */
    create<T extends facturasCreateArgs>(args: SelectSubset<T, facturasCreateArgs<ExtArgs>>): Prisma__facturasClient<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Facturas.
     * @param {facturasCreateManyArgs} args - Arguments to create many Facturas.
     * @example
     * // Create many Facturas
     * const facturas = await prisma.facturas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends facturasCreateManyArgs>(args?: SelectSubset<T, facturasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Facturas and returns the data saved in the database.
     * @param {facturasCreateManyAndReturnArgs} args - Arguments to create many Facturas.
     * @example
     * // Create many Facturas
     * const facturas = await prisma.facturas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Facturas and only return the `id_factura`
     * const facturasWithId_facturaOnly = await prisma.facturas.createManyAndReturn({ 
     *   select: { id_factura: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends facturasCreateManyAndReturnArgs>(args?: SelectSubset<T, facturasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Facturas.
     * @param {facturasDeleteArgs} args - Arguments to delete one Facturas.
     * @example
     * // Delete one Facturas
     * const Facturas = await prisma.facturas.delete({
     *   where: {
     *     // ... filter to delete one Facturas
     *   }
     * })
     * 
     */
    delete<T extends facturasDeleteArgs>(args: SelectSubset<T, facturasDeleteArgs<ExtArgs>>): Prisma__facturasClient<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Facturas.
     * @param {facturasUpdateArgs} args - Arguments to update one Facturas.
     * @example
     * // Update one Facturas
     * const facturas = await prisma.facturas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends facturasUpdateArgs>(args: SelectSubset<T, facturasUpdateArgs<ExtArgs>>): Prisma__facturasClient<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Facturas.
     * @param {facturasDeleteManyArgs} args - Arguments to filter Facturas to delete.
     * @example
     * // Delete a few Facturas
     * const { count } = await prisma.facturas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends facturasDeleteManyArgs>(args?: SelectSubset<T, facturasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Facturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Facturas
     * const facturas = await prisma.facturas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends facturasUpdateManyArgs>(args: SelectSubset<T, facturasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Facturas.
     * @param {facturasUpsertArgs} args - Arguments to update or create a Facturas.
     * @example
     * // Update or create a Facturas
     * const facturas = await prisma.facturas.upsert({
     *   create: {
     *     // ... data to create a Facturas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Facturas we want to update
     *   }
     * })
     */
    upsert<T extends facturasUpsertArgs>(args: SelectSubset<T, facturasUpsertArgs<ExtArgs>>): Prisma__facturasClient<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Facturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturasCountArgs} args - Arguments to filter Facturas to count.
     * @example
     * // Count the number of Facturas
     * const count = await prisma.facturas.count({
     *   where: {
     *     // ... the filter for the Facturas we want to count
     *   }
     * })
    **/
    count<T extends facturasCountArgs>(
      args?: Subset<T, facturasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacturasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Facturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacturasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacturasAggregateArgs>(args: Subset<T, FacturasAggregateArgs>): Prisma.PrismaPromise<GetFacturasAggregateType<T>>

    /**
     * Group by Facturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends facturasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: facturasGroupByArgs['orderBy'] }
        : { orderBy?: facturasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, facturasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacturasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the facturas model
   */
  readonly fields: facturasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for facturas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__facturasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orden<T extends ordenes_servicioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ordenes_servicioDefaultArgs<ExtArgs>>): Prisma__ordenes_servicioClient<$Result.GetResult<Prisma.$ordenes_servicioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the facturas model
   */ 
  interface facturasFieldRefs {
    readonly id_factura: FieldRef<"facturas", 'Int'>
    readonly id_orden: FieldRef<"facturas", 'Int'>
    readonly fecha: FieldRef<"facturas", 'DateTime'>
    readonly subtotal: FieldRef<"facturas", 'Decimal'>
    readonly iva: FieldRef<"facturas", 'Decimal'>
    readonly total: FieldRef<"facturas", 'Decimal'>
    readonly metodo_pago: FieldRef<"facturas", 'String'>
    readonly created_at: FieldRef<"facturas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * facturas findUnique
   */
  export type facturasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
    /**
     * Filter, which facturas to fetch.
     */
    where: facturasWhereUniqueInput
  }

  /**
   * facturas findUniqueOrThrow
   */
  export type facturasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
    /**
     * Filter, which facturas to fetch.
     */
    where: facturasWhereUniqueInput
  }

  /**
   * facturas findFirst
   */
  export type facturasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
    /**
     * Filter, which facturas to fetch.
     */
    where?: facturasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of facturas to fetch.
     */
    orderBy?: facturasOrderByWithRelationInput | facturasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for facturas.
     */
    cursor?: facturasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` facturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of facturas.
     */
    distinct?: FacturasScalarFieldEnum | FacturasScalarFieldEnum[]
  }

  /**
   * facturas findFirstOrThrow
   */
  export type facturasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
    /**
     * Filter, which facturas to fetch.
     */
    where?: facturasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of facturas to fetch.
     */
    orderBy?: facturasOrderByWithRelationInput | facturasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for facturas.
     */
    cursor?: facturasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` facturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of facturas.
     */
    distinct?: FacturasScalarFieldEnum | FacturasScalarFieldEnum[]
  }

  /**
   * facturas findMany
   */
  export type facturasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
    /**
     * Filter, which facturas to fetch.
     */
    where?: facturasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of facturas to fetch.
     */
    orderBy?: facturasOrderByWithRelationInput | facturasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing facturas.
     */
    cursor?: facturasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` facturas.
     */
    skip?: number
    distinct?: FacturasScalarFieldEnum | FacturasScalarFieldEnum[]
  }

  /**
   * facturas create
   */
  export type facturasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
    /**
     * The data needed to create a facturas.
     */
    data: XOR<facturasCreateInput, facturasUncheckedCreateInput>
  }

  /**
   * facturas createMany
   */
  export type facturasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many facturas.
     */
    data: facturasCreateManyInput | facturasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * facturas createManyAndReturn
   */
  export type facturasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many facturas.
     */
    data: facturasCreateManyInput | facturasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * facturas update
   */
  export type facturasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
    /**
     * The data needed to update a facturas.
     */
    data: XOR<facturasUpdateInput, facturasUncheckedUpdateInput>
    /**
     * Choose, which facturas to update.
     */
    where: facturasWhereUniqueInput
  }

  /**
   * facturas updateMany
   */
  export type facturasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update facturas.
     */
    data: XOR<facturasUpdateManyMutationInput, facturasUncheckedUpdateManyInput>
    /**
     * Filter which facturas to update
     */
    where?: facturasWhereInput
  }

  /**
   * facturas upsert
   */
  export type facturasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
    /**
     * The filter to search for the facturas to update in case it exists.
     */
    where: facturasWhereUniqueInput
    /**
     * In case the facturas found by the `where` argument doesn't exist, create a new facturas with this data.
     */
    create: XOR<facturasCreateInput, facturasUncheckedCreateInput>
    /**
     * In case the facturas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<facturasUpdateInput, facturasUncheckedUpdateInput>
  }

  /**
   * facturas delete
   */
  export type facturasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
    /**
     * Filter which facturas to delete.
     */
    where: facturasWhereUniqueInput
  }

  /**
   * facturas deleteMany
   */
  export type facturasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which facturas to delete
     */
    where?: facturasWhereInput
  }

  /**
   * facturas without action
   */
  export type facturasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsersScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    nombre: 'nombre',
    rol: 'rol',
    activo: 'activo',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const ClientesScalarFieldEnum: {
    id_cliente: 'id_cliente',
    nombre: 'nombre',
    direccion: 'direccion',
    telefono: 'telefono',
    correo: 'correo',
    created_at: 'created_at'
  };

  export type ClientesScalarFieldEnum = (typeof ClientesScalarFieldEnum)[keyof typeof ClientesScalarFieldEnum]


  export const VehiculosScalarFieldEnum: {
    id_vehiculo: 'id_vehiculo',
    id_cliente: 'id_cliente',
    marca: 'marca',
    modelo: 'modelo',
    anio: 'anio',
    placas: 'placas',
    color: 'color',
    vin: 'vin',
    created_at: 'created_at'
  };

  export type VehiculosScalarFieldEnum = (typeof VehiculosScalarFieldEnum)[keyof typeof VehiculosScalarFieldEnum]


  export const ServiciosScalarFieldEnum: {
    id_servicio: 'id_servicio',
    nombre: 'nombre',
    descripcion: 'descripcion',
    precio: 'precio',
    tiempo_est: 'tiempo_est',
    activo: 'activo',
    created_at: 'created_at'
  };

  export type ServiciosScalarFieldEnum = (typeof ServiciosScalarFieldEnum)[keyof typeof ServiciosScalarFieldEnum]


  export const EmpleadosScalarFieldEnum: {
    id_empleado: 'id_empleado',
    nombre: 'nombre',
    especialidad: 'especialidad',
    telefono: 'telefono',
    salario: 'salario',
    activo: 'activo',
    created_at: 'created_at'
  };

  export type EmpleadosScalarFieldEnum = (typeof EmpleadosScalarFieldEnum)[keyof typeof EmpleadosScalarFieldEnum]


  export const Ordenes_servicioScalarFieldEnum: {
    id_orden: 'id_orden',
    id_vehiculo: 'id_vehiculo',
    id_empleado: 'id_empleado',
    fecha_entrada: 'fecha_entrada',
    fecha_salida: 'fecha_salida',
    observaciones: 'observaciones',
    estado: 'estado',
    kilometraje: 'kilometraje',
    created_at: 'created_at'
  };

  export type Ordenes_servicioScalarFieldEnum = (typeof Ordenes_servicioScalarFieldEnum)[keyof typeof Ordenes_servicioScalarFieldEnum]


  export const Detalle_ordenScalarFieldEnum: {
    id_detalle: 'id_detalle',
    id_orden: 'id_orden',
    id_servicio: 'id_servicio',
    cantidad: 'cantidad',
    precio_unit: 'precio_unit',
    subtotal: 'subtotal',
    created_at: 'created_at'
  };

  export type Detalle_ordenScalarFieldEnum = (typeof Detalle_ordenScalarFieldEnum)[keyof typeof Detalle_ordenScalarFieldEnum]


  export const FacturasScalarFieldEnum: {
    id_factura: 'id_factura',
    id_orden: 'id_orden',
    fecha: 'fecha',
    subtotal: 'subtotal',
    iva: 'iva',
    total: 'total',
    metodo_pago: 'metodo_pago',
    created_at: 'created_at'
  };

  export type FacturasScalarFieldEnum = (typeof FacturasScalarFieldEnum)[keyof typeof FacturasScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: UuidFilter<"users"> | string
    email?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    nombre?: StringFilter<"users"> | string
    rol?: StringFilter<"users"> | string
    activo?: BoolFilter<"users"> | boolean
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nombre?: SortOrder
    rol?: SortOrder
    activo?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    password?: StringFilter<"users"> | string
    nombre?: StringFilter<"users"> | string
    rol?: StringFilter<"users"> | string
    activo?: BoolFilter<"users"> | boolean
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
  }, "id" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nombre?: SortOrder
    rol?: SortOrder
    activo?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    nombre?: StringWithAggregatesFilter<"users"> | string
    rol?: StringWithAggregatesFilter<"users"> | string
    activo?: BoolWithAggregatesFilter<"users"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
  }

  export type clientesWhereInput = {
    AND?: clientesWhereInput | clientesWhereInput[]
    OR?: clientesWhereInput[]
    NOT?: clientesWhereInput | clientesWhereInput[]
    id_cliente?: IntFilter<"clientes"> | number
    nombre?: StringFilter<"clientes"> | string
    direccion?: StringNullableFilter<"clientes"> | string | null
    telefono?: StringFilter<"clientes"> | string
    correo?: StringNullableFilter<"clientes"> | string | null
    created_at?: DateTimeNullableFilter<"clientes"> | Date | string | null
    vehiculos?: VehiculosListRelationFilter
  }

  export type clientesOrderByWithRelationInput = {
    id_cliente?: SortOrder
    nombre?: SortOrder
    direccion?: SortOrderInput | SortOrder
    telefono?: SortOrder
    correo?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    vehiculos?: vehiculosOrderByRelationAggregateInput
  }

  export type clientesWhereUniqueInput = Prisma.AtLeast<{
    id_cliente?: number
    AND?: clientesWhereInput | clientesWhereInput[]
    OR?: clientesWhereInput[]
    NOT?: clientesWhereInput | clientesWhereInput[]
    nombre?: StringFilter<"clientes"> | string
    direccion?: StringNullableFilter<"clientes"> | string | null
    telefono?: StringFilter<"clientes"> | string
    correo?: StringNullableFilter<"clientes"> | string | null
    created_at?: DateTimeNullableFilter<"clientes"> | Date | string | null
    vehiculos?: VehiculosListRelationFilter
  }, "id_cliente">

  export type clientesOrderByWithAggregationInput = {
    id_cliente?: SortOrder
    nombre?: SortOrder
    direccion?: SortOrderInput | SortOrder
    telefono?: SortOrder
    correo?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: clientesCountOrderByAggregateInput
    _avg?: clientesAvgOrderByAggregateInput
    _max?: clientesMaxOrderByAggregateInput
    _min?: clientesMinOrderByAggregateInput
    _sum?: clientesSumOrderByAggregateInput
  }

  export type clientesScalarWhereWithAggregatesInput = {
    AND?: clientesScalarWhereWithAggregatesInput | clientesScalarWhereWithAggregatesInput[]
    OR?: clientesScalarWhereWithAggregatesInput[]
    NOT?: clientesScalarWhereWithAggregatesInput | clientesScalarWhereWithAggregatesInput[]
    id_cliente?: IntWithAggregatesFilter<"clientes"> | number
    nombre?: StringWithAggregatesFilter<"clientes"> | string
    direccion?: StringNullableWithAggregatesFilter<"clientes"> | string | null
    telefono?: StringWithAggregatesFilter<"clientes"> | string
    correo?: StringNullableWithAggregatesFilter<"clientes"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"clientes"> | Date | string | null
  }

  export type vehiculosWhereInput = {
    AND?: vehiculosWhereInput | vehiculosWhereInput[]
    OR?: vehiculosWhereInput[]
    NOT?: vehiculosWhereInput | vehiculosWhereInput[]
    id_vehiculo?: IntFilter<"vehiculos"> | number
    id_cliente?: IntFilter<"vehiculos"> | number
    marca?: StringFilter<"vehiculos"> | string
    modelo?: StringFilter<"vehiculos"> | string
    anio?: IntFilter<"vehiculos"> | number
    placas?: StringFilter<"vehiculos"> | string
    color?: StringNullableFilter<"vehiculos"> | string | null
    vin?: StringNullableFilter<"vehiculos"> | string | null
    created_at?: DateTimeNullableFilter<"vehiculos"> | Date | string | null
    cliente?: XOR<ClientesRelationFilter, clientesWhereInput>
    ordenes_servicio?: Ordenes_servicioListRelationFilter
  }

  export type vehiculosOrderByWithRelationInput = {
    id_vehiculo?: SortOrder
    id_cliente?: SortOrder
    marca?: SortOrder
    modelo?: SortOrder
    anio?: SortOrder
    placas?: SortOrder
    color?: SortOrderInput | SortOrder
    vin?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    cliente?: clientesOrderByWithRelationInput
    ordenes_servicio?: ordenes_servicioOrderByRelationAggregateInput
  }

  export type vehiculosWhereUniqueInput = Prisma.AtLeast<{
    id_vehiculo?: number
    placas?: string
    vin?: string
    AND?: vehiculosWhereInput | vehiculosWhereInput[]
    OR?: vehiculosWhereInput[]
    NOT?: vehiculosWhereInput | vehiculosWhereInput[]
    id_cliente?: IntFilter<"vehiculos"> | number
    marca?: StringFilter<"vehiculos"> | string
    modelo?: StringFilter<"vehiculos"> | string
    anio?: IntFilter<"vehiculos"> | number
    color?: StringNullableFilter<"vehiculos"> | string | null
    created_at?: DateTimeNullableFilter<"vehiculos"> | Date | string | null
    cliente?: XOR<ClientesRelationFilter, clientesWhereInput>
    ordenes_servicio?: Ordenes_servicioListRelationFilter
  }, "id_vehiculo" | "placas" | "vin">

  export type vehiculosOrderByWithAggregationInput = {
    id_vehiculo?: SortOrder
    id_cliente?: SortOrder
    marca?: SortOrder
    modelo?: SortOrder
    anio?: SortOrder
    placas?: SortOrder
    color?: SortOrderInput | SortOrder
    vin?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: vehiculosCountOrderByAggregateInput
    _avg?: vehiculosAvgOrderByAggregateInput
    _max?: vehiculosMaxOrderByAggregateInput
    _min?: vehiculosMinOrderByAggregateInput
    _sum?: vehiculosSumOrderByAggregateInput
  }

  export type vehiculosScalarWhereWithAggregatesInput = {
    AND?: vehiculosScalarWhereWithAggregatesInput | vehiculosScalarWhereWithAggregatesInput[]
    OR?: vehiculosScalarWhereWithAggregatesInput[]
    NOT?: vehiculosScalarWhereWithAggregatesInput | vehiculosScalarWhereWithAggregatesInput[]
    id_vehiculo?: IntWithAggregatesFilter<"vehiculos"> | number
    id_cliente?: IntWithAggregatesFilter<"vehiculos"> | number
    marca?: StringWithAggregatesFilter<"vehiculos"> | string
    modelo?: StringWithAggregatesFilter<"vehiculos"> | string
    anio?: IntWithAggregatesFilter<"vehiculos"> | number
    placas?: StringWithAggregatesFilter<"vehiculos"> | string
    color?: StringNullableWithAggregatesFilter<"vehiculos"> | string | null
    vin?: StringNullableWithAggregatesFilter<"vehiculos"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"vehiculos"> | Date | string | null
  }

  export type serviciosWhereInput = {
    AND?: serviciosWhereInput | serviciosWhereInput[]
    OR?: serviciosWhereInput[]
    NOT?: serviciosWhereInput | serviciosWhereInput[]
    id_servicio?: IntFilter<"servicios"> | number
    nombre?: StringFilter<"servicios"> | string
    descripcion?: StringNullableFilter<"servicios"> | string | null
    precio?: DecimalFilter<"servicios"> | Decimal | DecimalJsLike | number | string
    tiempo_est?: IntNullableFilter<"servicios"> | number | null
    activo?: BoolFilter<"servicios"> | boolean
    created_at?: DateTimeNullableFilter<"servicios"> | Date | string | null
    detalle_orden?: Detalle_ordenListRelationFilter
  }

  export type serviciosOrderByWithRelationInput = {
    id_servicio?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    precio?: SortOrder
    tiempo_est?: SortOrderInput | SortOrder
    activo?: SortOrder
    created_at?: SortOrderInput | SortOrder
    detalle_orden?: detalle_ordenOrderByRelationAggregateInput
  }

  export type serviciosWhereUniqueInput = Prisma.AtLeast<{
    id_servicio?: number
    AND?: serviciosWhereInput | serviciosWhereInput[]
    OR?: serviciosWhereInput[]
    NOT?: serviciosWhereInput | serviciosWhereInput[]
    nombre?: StringFilter<"servicios"> | string
    descripcion?: StringNullableFilter<"servicios"> | string | null
    precio?: DecimalFilter<"servicios"> | Decimal | DecimalJsLike | number | string
    tiempo_est?: IntNullableFilter<"servicios"> | number | null
    activo?: BoolFilter<"servicios"> | boolean
    created_at?: DateTimeNullableFilter<"servicios"> | Date | string | null
    detalle_orden?: Detalle_ordenListRelationFilter
  }, "id_servicio">

  export type serviciosOrderByWithAggregationInput = {
    id_servicio?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    precio?: SortOrder
    tiempo_est?: SortOrderInput | SortOrder
    activo?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: serviciosCountOrderByAggregateInput
    _avg?: serviciosAvgOrderByAggregateInput
    _max?: serviciosMaxOrderByAggregateInput
    _min?: serviciosMinOrderByAggregateInput
    _sum?: serviciosSumOrderByAggregateInput
  }

  export type serviciosScalarWhereWithAggregatesInput = {
    AND?: serviciosScalarWhereWithAggregatesInput | serviciosScalarWhereWithAggregatesInput[]
    OR?: serviciosScalarWhereWithAggregatesInput[]
    NOT?: serviciosScalarWhereWithAggregatesInput | serviciosScalarWhereWithAggregatesInput[]
    id_servicio?: IntWithAggregatesFilter<"servicios"> | number
    nombre?: StringWithAggregatesFilter<"servicios"> | string
    descripcion?: StringNullableWithAggregatesFilter<"servicios"> | string | null
    precio?: DecimalWithAggregatesFilter<"servicios"> | Decimal | DecimalJsLike | number | string
    tiempo_est?: IntNullableWithAggregatesFilter<"servicios"> | number | null
    activo?: BoolWithAggregatesFilter<"servicios"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"servicios"> | Date | string | null
  }

  export type empleadosWhereInput = {
    AND?: empleadosWhereInput | empleadosWhereInput[]
    OR?: empleadosWhereInput[]
    NOT?: empleadosWhereInput | empleadosWhereInput[]
    id_empleado?: IntFilter<"empleados"> | number
    nombre?: StringFilter<"empleados"> | string
    especialidad?: StringNullableFilter<"empleados"> | string | null
    telefono?: StringNullableFilter<"empleados"> | string | null
    salario?: DecimalNullableFilter<"empleados"> | Decimal | DecimalJsLike | number | string | null
    activo?: BoolFilter<"empleados"> | boolean
    created_at?: DateTimeNullableFilter<"empleados"> | Date | string | null
    ordenes_servicio?: Ordenes_servicioListRelationFilter
  }

  export type empleadosOrderByWithRelationInput = {
    id_empleado?: SortOrder
    nombre?: SortOrder
    especialidad?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    salario?: SortOrderInput | SortOrder
    activo?: SortOrder
    created_at?: SortOrderInput | SortOrder
    ordenes_servicio?: ordenes_servicioOrderByRelationAggregateInput
  }

  export type empleadosWhereUniqueInput = Prisma.AtLeast<{
    id_empleado?: number
    AND?: empleadosWhereInput | empleadosWhereInput[]
    OR?: empleadosWhereInput[]
    NOT?: empleadosWhereInput | empleadosWhereInput[]
    nombre?: StringFilter<"empleados"> | string
    especialidad?: StringNullableFilter<"empleados"> | string | null
    telefono?: StringNullableFilter<"empleados"> | string | null
    salario?: DecimalNullableFilter<"empleados"> | Decimal | DecimalJsLike | number | string | null
    activo?: BoolFilter<"empleados"> | boolean
    created_at?: DateTimeNullableFilter<"empleados"> | Date | string | null
    ordenes_servicio?: Ordenes_servicioListRelationFilter
  }, "id_empleado">

  export type empleadosOrderByWithAggregationInput = {
    id_empleado?: SortOrder
    nombre?: SortOrder
    especialidad?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    salario?: SortOrderInput | SortOrder
    activo?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: empleadosCountOrderByAggregateInput
    _avg?: empleadosAvgOrderByAggregateInput
    _max?: empleadosMaxOrderByAggregateInput
    _min?: empleadosMinOrderByAggregateInput
    _sum?: empleadosSumOrderByAggregateInput
  }

  export type empleadosScalarWhereWithAggregatesInput = {
    AND?: empleadosScalarWhereWithAggregatesInput | empleadosScalarWhereWithAggregatesInput[]
    OR?: empleadosScalarWhereWithAggregatesInput[]
    NOT?: empleadosScalarWhereWithAggregatesInput | empleadosScalarWhereWithAggregatesInput[]
    id_empleado?: IntWithAggregatesFilter<"empleados"> | number
    nombre?: StringWithAggregatesFilter<"empleados"> | string
    especialidad?: StringNullableWithAggregatesFilter<"empleados"> | string | null
    telefono?: StringNullableWithAggregatesFilter<"empleados"> | string | null
    salario?: DecimalNullableWithAggregatesFilter<"empleados"> | Decimal | DecimalJsLike | number | string | null
    activo?: BoolWithAggregatesFilter<"empleados"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"empleados"> | Date | string | null
  }

  export type ordenes_servicioWhereInput = {
    AND?: ordenes_servicioWhereInput | ordenes_servicioWhereInput[]
    OR?: ordenes_servicioWhereInput[]
    NOT?: ordenes_servicioWhereInput | ordenes_servicioWhereInput[]
    id_orden?: IntFilter<"ordenes_servicio"> | number
    id_vehiculo?: IntFilter<"ordenes_servicio"> | number
    id_empleado?: IntNullableFilter<"ordenes_servicio"> | number | null
    fecha_entrada?: DateTimeFilter<"ordenes_servicio"> | Date | string
    fecha_salida?: DateTimeNullableFilter<"ordenes_servicio"> | Date | string | null
    observaciones?: StringNullableFilter<"ordenes_servicio"> | string | null
    estado?: StringFilter<"ordenes_servicio"> | string
    kilometraje?: IntNullableFilter<"ordenes_servicio"> | number | null
    created_at?: DateTimeNullableFilter<"ordenes_servicio"> | Date | string | null
    vehiculo?: XOR<VehiculosRelationFilter, vehiculosWhereInput>
    empleado?: XOR<EmpleadosNullableRelationFilter, empleadosWhereInput> | null
    detalle_orden?: Detalle_ordenListRelationFilter
    facturas?: FacturasListRelationFilter
  }

  export type ordenes_servicioOrderByWithRelationInput = {
    id_orden?: SortOrder
    id_vehiculo?: SortOrder
    id_empleado?: SortOrderInput | SortOrder
    fecha_entrada?: SortOrder
    fecha_salida?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    estado?: SortOrder
    kilometraje?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    vehiculo?: vehiculosOrderByWithRelationInput
    empleado?: empleadosOrderByWithRelationInput
    detalle_orden?: detalle_ordenOrderByRelationAggregateInput
    facturas?: facturasOrderByRelationAggregateInput
  }

  export type ordenes_servicioWhereUniqueInput = Prisma.AtLeast<{
    id_orden?: number
    AND?: ordenes_servicioWhereInput | ordenes_servicioWhereInput[]
    OR?: ordenes_servicioWhereInput[]
    NOT?: ordenes_servicioWhereInput | ordenes_servicioWhereInput[]
    id_vehiculo?: IntFilter<"ordenes_servicio"> | number
    id_empleado?: IntNullableFilter<"ordenes_servicio"> | number | null
    fecha_entrada?: DateTimeFilter<"ordenes_servicio"> | Date | string
    fecha_salida?: DateTimeNullableFilter<"ordenes_servicio"> | Date | string | null
    observaciones?: StringNullableFilter<"ordenes_servicio"> | string | null
    estado?: StringFilter<"ordenes_servicio"> | string
    kilometraje?: IntNullableFilter<"ordenes_servicio"> | number | null
    created_at?: DateTimeNullableFilter<"ordenes_servicio"> | Date | string | null
    vehiculo?: XOR<VehiculosRelationFilter, vehiculosWhereInput>
    empleado?: XOR<EmpleadosNullableRelationFilter, empleadosWhereInput> | null
    detalle_orden?: Detalle_ordenListRelationFilter
    facturas?: FacturasListRelationFilter
  }, "id_orden">

  export type ordenes_servicioOrderByWithAggregationInput = {
    id_orden?: SortOrder
    id_vehiculo?: SortOrder
    id_empleado?: SortOrderInput | SortOrder
    fecha_entrada?: SortOrder
    fecha_salida?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    estado?: SortOrder
    kilometraje?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: ordenes_servicioCountOrderByAggregateInput
    _avg?: ordenes_servicioAvgOrderByAggregateInput
    _max?: ordenes_servicioMaxOrderByAggregateInput
    _min?: ordenes_servicioMinOrderByAggregateInput
    _sum?: ordenes_servicioSumOrderByAggregateInput
  }

  export type ordenes_servicioScalarWhereWithAggregatesInput = {
    AND?: ordenes_servicioScalarWhereWithAggregatesInput | ordenes_servicioScalarWhereWithAggregatesInput[]
    OR?: ordenes_servicioScalarWhereWithAggregatesInput[]
    NOT?: ordenes_servicioScalarWhereWithAggregatesInput | ordenes_servicioScalarWhereWithAggregatesInput[]
    id_orden?: IntWithAggregatesFilter<"ordenes_servicio"> | number
    id_vehiculo?: IntWithAggregatesFilter<"ordenes_servicio"> | number
    id_empleado?: IntNullableWithAggregatesFilter<"ordenes_servicio"> | number | null
    fecha_entrada?: DateTimeWithAggregatesFilter<"ordenes_servicio"> | Date | string
    fecha_salida?: DateTimeNullableWithAggregatesFilter<"ordenes_servicio"> | Date | string | null
    observaciones?: StringNullableWithAggregatesFilter<"ordenes_servicio"> | string | null
    estado?: StringWithAggregatesFilter<"ordenes_servicio"> | string
    kilometraje?: IntNullableWithAggregatesFilter<"ordenes_servicio"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"ordenes_servicio"> | Date | string | null
  }

  export type detalle_ordenWhereInput = {
    AND?: detalle_ordenWhereInput | detalle_ordenWhereInput[]
    OR?: detalle_ordenWhereInput[]
    NOT?: detalle_ordenWhereInput | detalle_ordenWhereInput[]
    id_detalle?: IntFilter<"detalle_orden"> | number
    id_orden?: IntFilter<"detalle_orden"> | number
    id_servicio?: IntFilter<"detalle_orden"> | number
    cantidad?: IntFilter<"detalle_orden"> | number
    precio_unit?: DecimalFilter<"detalle_orden"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"detalle_orden"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeNullableFilter<"detalle_orden"> | Date | string | null
    orden?: XOR<Ordenes_servicioRelationFilter, ordenes_servicioWhereInput>
    servicio?: XOR<ServiciosRelationFilter, serviciosWhereInput>
  }

  export type detalle_ordenOrderByWithRelationInput = {
    id_detalle?: SortOrder
    id_orden?: SortOrder
    id_servicio?: SortOrder
    cantidad?: SortOrder
    precio_unit?: SortOrder
    subtotal?: SortOrder
    created_at?: SortOrderInput | SortOrder
    orden?: ordenes_servicioOrderByWithRelationInput
    servicio?: serviciosOrderByWithRelationInput
  }

  export type detalle_ordenWhereUniqueInput = Prisma.AtLeast<{
    id_detalle?: number
    AND?: detalle_ordenWhereInput | detalle_ordenWhereInput[]
    OR?: detalle_ordenWhereInput[]
    NOT?: detalle_ordenWhereInput | detalle_ordenWhereInput[]
    id_orden?: IntFilter<"detalle_orden"> | number
    id_servicio?: IntFilter<"detalle_orden"> | number
    cantidad?: IntFilter<"detalle_orden"> | number
    precio_unit?: DecimalFilter<"detalle_orden"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"detalle_orden"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeNullableFilter<"detalle_orden"> | Date | string | null
    orden?: XOR<Ordenes_servicioRelationFilter, ordenes_servicioWhereInput>
    servicio?: XOR<ServiciosRelationFilter, serviciosWhereInput>
  }, "id_detalle">

  export type detalle_ordenOrderByWithAggregationInput = {
    id_detalle?: SortOrder
    id_orden?: SortOrder
    id_servicio?: SortOrder
    cantidad?: SortOrder
    precio_unit?: SortOrder
    subtotal?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: detalle_ordenCountOrderByAggregateInput
    _avg?: detalle_ordenAvgOrderByAggregateInput
    _max?: detalle_ordenMaxOrderByAggregateInput
    _min?: detalle_ordenMinOrderByAggregateInput
    _sum?: detalle_ordenSumOrderByAggregateInput
  }

  export type detalle_ordenScalarWhereWithAggregatesInput = {
    AND?: detalle_ordenScalarWhereWithAggregatesInput | detalle_ordenScalarWhereWithAggregatesInput[]
    OR?: detalle_ordenScalarWhereWithAggregatesInput[]
    NOT?: detalle_ordenScalarWhereWithAggregatesInput | detalle_ordenScalarWhereWithAggregatesInput[]
    id_detalle?: IntWithAggregatesFilter<"detalle_orden"> | number
    id_orden?: IntWithAggregatesFilter<"detalle_orden"> | number
    id_servicio?: IntWithAggregatesFilter<"detalle_orden"> | number
    cantidad?: IntWithAggregatesFilter<"detalle_orden"> | number
    precio_unit?: DecimalWithAggregatesFilter<"detalle_orden"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalWithAggregatesFilter<"detalle_orden"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeNullableWithAggregatesFilter<"detalle_orden"> | Date | string | null
  }

  export type facturasWhereInput = {
    AND?: facturasWhereInput | facturasWhereInput[]
    OR?: facturasWhereInput[]
    NOT?: facturasWhereInput | facturasWhereInput[]
    id_factura?: IntFilter<"facturas"> | number
    id_orden?: IntFilter<"facturas"> | number
    fecha?: DateTimeFilter<"facturas"> | Date | string
    subtotal?: DecimalFilter<"facturas"> | Decimal | DecimalJsLike | number | string
    iva?: DecimalFilter<"facturas"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"facturas"> | Decimal | DecimalJsLike | number | string
    metodo_pago?: StringNullableFilter<"facturas"> | string | null
    created_at?: DateTimeNullableFilter<"facturas"> | Date | string | null
    orden?: XOR<Ordenes_servicioRelationFilter, ordenes_servicioWhereInput>
  }

  export type facturasOrderByWithRelationInput = {
    id_factura?: SortOrder
    id_orden?: SortOrder
    fecha?: SortOrder
    subtotal?: SortOrder
    iva?: SortOrder
    total?: SortOrder
    metodo_pago?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    orden?: ordenes_servicioOrderByWithRelationInput
  }

  export type facturasWhereUniqueInput = Prisma.AtLeast<{
    id_factura?: number
    id_orden?: number
    AND?: facturasWhereInput | facturasWhereInput[]
    OR?: facturasWhereInput[]
    NOT?: facturasWhereInput | facturasWhereInput[]
    fecha?: DateTimeFilter<"facturas"> | Date | string
    subtotal?: DecimalFilter<"facturas"> | Decimal | DecimalJsLike | number | string
    iva?: DecimalFilter<"facturas"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"facturas"> | Decimal | DecimalJsLike | number | string
    metodo_pago?: StringNullableFilter<"facturas"> | string | null
    created_at?: DateTimeNullableFilter<"facturas"> | Date | string | null
    orden?: XOR<Ordenes_servicioRelationFilter, ordenes_servicioWhereInput>
  }, "id_factura" | "id_orden">

  export type facturasOrderByWithAggregationInput = {
    id_factura?: SortOrder
    id_orden?: SortOrder
    fecha?: SortOrder
    subtotal?: SortOrder
    iva?: SortOrder
    total?: SortOrder
    metodo_pago?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: facturasCountOrderByAggregateInput
    _avg?: facturasAvgOrderByAggregateInput
    _max?: facturasMaxOrderByAggregateInput
    _min?: facturasMinOrderByAggregateInput
    _sum?: facturasSumOrderByAggregateInput
  }

  export type facturasScalarWhereWithAggregatesInput = {
    AND?: facturasScalarWhereWithAggregatesInput | facturasScalarWhereWithAggregatesInput[]
    OR?: facturasScalarWhereWithAggregatesInput[]
    NOT?: facturasScalarWhereWithAggregatesInput | facturasScalarWhereWithAggregatesInput[]
    id_factura?: IntWithAggregatesFilter<"facturas"> | number
    id_orden?: IntWithAggregatesFilter<"facturas"> | number
    fecha?: DateTimeWithAggregatesFilter<"facturas"> | Date | string
    subtotal?: DecimalWithAggregatesFilter<"facturas"> | Decimal | DecimalJsLike | number | string
    iva?: DecimalWithAggregatesFilter<"facturas"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"facturas"> | Decimal | DecimalJsLike | number | string
    metodo_pago?: StringNullableWithAggregatesFilter<"facturas"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"facturas"> | Date | string | null
  }

  export type usersCreateInput = {
    id?: string
    email: string
    password: string
    nombre: string
    rol?: string
    activo?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usersUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    nombre: string
    rol?: string
    activo?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateManyInput = {
    id?: string
    email: string
    password: string
    nombre: string
    rol?: string
    activo?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type clientesCreateInput = {
    nombre: string
    direccion?: string | null
    telefono: string
    correo?: string | null
    created_at?: Date | string | null
    vehiculos?: vehiculosCreateNestedManyWithoutClienteInput
  }

  export type clientesUncheckedCreateInput = {
    id_cliente?: number
    nombre: string
    direccion?: string | null
    telefono: string
    correo?: string | null
    created_at?: Date | string | null
    vehiculos?: vehiculosUncheckedCreateNestedManyWithoutClienteInput
  }

  export type clientesUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehiculos?: vehiculosUpdateManyWithoutClienteNestedInput
  }

  export type clientesUncheckedUpdateInput = {
    id_cliente?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehiculos?: vehiculosUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type clientesCreateManyInput = {
    id_cliente?: number
    nombre: string
    direccion?: string | null
    telefono: string
    correo?: string | null
    created_at?: Date | string | null
  }

  export type clientesUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type clientesUncheckedUpdateManyInput = {
    id_cliente?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type vehiculosCreateInput = {
    marca: string
    modelo: string
    anio: number
    placas: string
    color?: string | null
    vin?: string | null
    created_at?: Date | string | null
    cliente: clientesCreateNestedOneWithoutVehiculosInput
    ordenes_servicio?: ordenes_servicioCreateNestedManyWithoutVehiculoInput
  }

  export type vehiculosUncheckedCreateInput = {
    id_vehiculo?: number
    id_cliente: number
    marca: string
    modelo: string
    anio: number
    placas: string
    color?: string | null
    vin?: string | null
    created_at?: Date | string | null
    ordenes_servicio?: ordenes_servicioUncheckedCreateNestedManyWithoutVehiculoInput
  }

  export type vehiculosUpdateInput = {
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    placas?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cliente?: clientesUpdateOneRequiredWithoutVehiculosNestedInput
    ordenes_servicio?: ordenes_servicioUpdateManyWithoutVehiculoNestedInput
  }

  export type vehiculosUncheckedUpdateInput = {
    id_vehiculo?: IntFieldUpdateOperationsInput | number
    id_cliente?: IntFieldUpdateOperationsInput | number
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    placas?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ordenes_servicio?: ordenes_servicioUncheckedUpdateManyWithoutVehiculoNestedInput
  }

  export type vehiculosCreateManyInput = {
    id_vehiculo?: number
    id_cliente: number
    marca: string
    modelo: string
    anio: number
    placas: string
    color?: string | null
    vin?: string | null
    created_at?: Date | string | null
  }

  export type vehiculosUpdateManyMutationInput = {
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    placas?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type vehiculosUncheckedUpdateManyInput = {
    id_vehiculo?: IntFieldUpdateOperationsInput | number
    id_cliente?: IntFieldUpdateOperationsInput | number
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    placas?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviciosCreateInput = {
    nombre: string
    descripcion?: string | null
    precio: Decimal | DecimalJsLike | number | string
    tiempo_est?: number | null
    activo?: boolean
    created_at?: Date | string | null
    detalle_orden?: detalle_ordenCreateNestedManyWithoutServicioInput
  }

  export type serviciosUncheckedCreateInput = {
    id_servicio?: number
    nombre: string
    descripcion?: string | null
    precio: Decimal | DecimalJsLike | number | string
    tiempo_est?: number | null
    activo?: boolean
    created_at?: Date | string | null
    detalle_orden?: detalle_ordenUncheckedCreateNestedManyWithoutServicioInput
  }

  export type serviciosUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tiempo_est?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detalle_orden?: detalle_ordenUpdateManyWithoutServicioNestedInput
  }

  export type serviciosUncheckedUpdateInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tiempo_est?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detalle_orden?: detalle_ordenUncheckedUpdateManyWithoutServicioNestedInput
  }

  export type serviciosCreateManyInput = {
    id_servicio?: number
    nombre: string
    descripcion?: string | null
    precio: Decimal | DecimalJsLike | number | string
    tiempo_est?: number | null
    activo?: boolean
    created_at?: Date | string | null
  }

  export type serviciosUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tiempo_est?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviciosUncheckedUpdateManyInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tiempo_est?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type empleadosCreateInput = {
    nombre: string
    especialidad?: string | null
    telefono?: string | null
    salario?: Decimal | DecimalJsLike | number | string | null
    activo?: boolean
    created_at?: Date | string | null
    ordenes_servicio?: ordenes_servicioCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadosUncheckedCreateInput = {
    id_empleado?: number
    nombre: string
    especialidad?: string | null
    telefono?: string | null
    salario?: Decimal | DecimalJsLike | number | string | null
    activo?: boolean
    created_at?: Date | string | null
    ordenes_servicio?: ordenes_servicioUncheckedCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadosUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    salario?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ordenes_servicio?: ordenes_servicioUpdateManyWithoutEmpleadoNestedInput
  }

  export type empleadosUncheckedUpdateInput = {
    id_empleado?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    salario?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ordenes_servicio?: ordenes_servicioUncheckedUpdateManyWithoutEmpleadoNestedInput
  }

  export type empleadosCreateManyInput = {
    id_empleado?: number
    nombre: string
    especialidad?: string | null
    telefono?: string | null
    salario?: Decimal | DecimalJsLike | number | string | null
    activo?: boolean
    created_at?: Date | string | null
  }

  export type empleadosUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    salario?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type empleadosUncheckedUpdateManyInput = {
    id_empleado?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    salario?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ordenes_servicioCreateInput = {
    fecha_entrada?: Date | string
    fecha_salida?: Date | string | null
    observaciones?: string | null
    estado?: string
    kilometraje?: number | null
    created_at?: Date | string | null
    vehiculo: vehiculosCreateNestedOneWithoutOrdenes_servicioInput
    empleado?: empleadosCreateNestedOneWithoutOrdenes_servicioInput
    detalle_orden?: detalle_ordenCreateNestedManyWithoutOrdenInput
    facturas?: facturasCreateNestedManyWithoutOrdenInput
  }

  export type ordenes_servicioUncheckedCreateInput = {
    id_orden?: number
    id_vehiculo: number
    id_empleado?: number | null
    fecha_entrada?: Date | string
    fecha_salida?: Date | string | null
    observaciones?: string | null
    estado?: string
    kilometraje?: number | null
    created_at?: Date | string | null
    detalle_orden?: detalle_ordenUncheckedCreateNestedManyWithoutOrdenInput
    facturas?: facturasUncheckedCreateNestedManyWithoutOrdenInput
  }

  export type ordenes_servicioUpdateInput = {
    fecha_entrada?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    kilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehiculo?: vehiculosUpdateOneRequiredWithoutOrdenes_servicioNestedInput
    empleado?: empleadosUpdateOneWithoutOrdenes_servicioNestedInput
    detalle_orden?: detalle_ordenUpdateManyWithoutOrdenNestedInput
    facturas?: facturasUpdateManyWithoutOrdenNestedInput
  }

  export type ordenes_servicioUncheckedUpdateInput = {
    id_orden?: IntFieldUpdateOperationsInput | number
    id_vehiculo?: IntFieldUpdateOperationsInput | number
    id_empleado?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_entrada?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    kilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detalle_orden?: detalle_ordenUncheckedUpdateManyWithoutOrdenNestedInput
    facturas?: facturasUncheckedUpdateManyWithoutOrdenNestedInput
  }

  export type ordenes_servicioCreateManyInput = {
    id_orden?: number
    id_vehiculo: number
    id_empleado?: number | null
    fecha_entrada?: Date | string
    fecha_salida?: Date | string | null
    observaciones?: string | null
    estado?: string
    kilometraje?: number | null
    created_at?: Date | string | null
  }

  export type ordenes_servicioUpdateManyMutationInput = {
    fecha_entrada?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    kilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ordenes_servicioUncheckedUpdateManyInput = {
    id_orden?: IntFieldUpdateOperationsInput | number
    id_vehiculo?: IntFieldUpdateOperationsInput | number
    id_empleado?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_entrada?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    kilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type detalle_ordenCreateInput = {
    cantidad?: number
    precio_unit: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    orden: ordenes_servicioCreateNestedOneWithoutDetalle_ordenInput
    servicio: serviciosCreateNestedOneWithoutDetalle_ordenInput
  }

  export type detalle_ordenUncheckedCreateInput = {
    id_detalle?: number
    id_orden: number
    id_servicio: number
    cantidad?: number
    precio_unit: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
  }

  export type detalle_ordenUpdateInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orden?: ordenes_servicioUpdateOneRequiredWithoutDetalle_ordenNestedInput
    servicio?: serviciosUpdateOneRequiredWithoutDetalle_ordenNestedInput
  }

  export type detalle_ordenUncheckedUpdateInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_orden?: IntFieldUpdateOperationsInput | number
    id_servicio?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type detalle_ordenCreateManyInput = {
    id_detalle?: number
    id_orden: number
    id_servicio: number
    cantidad?: number
    precio_unit: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
  }

  export type detalle_ordenUpdateManyMutationInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type detalle_ordenUncheckedUpdateManyInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_orden?: IntFieldUpdateOperationsInput | number
    id_servicio?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type facturasCreateInput = {
    fecha?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    metodo_pago?: string | null
    created_at?: Date | string | null
    orden: ordenes_servicioCreateNestedOneWithoutFacturasInput
  }

  export type facturasUncheckedCreateInput = {
    id_factura?: number
    id_orden: number
    fecha?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    metodo_pago?: string | null
    created_at?: Date | string | null
  }

  export type facturasUpdateInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metodo_pago?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orden?: ordenes_servicioUpdateOneRequiredWithoutFacturasNestedInput
  }

  export type facturasUncheckedUpdateInput = {
    id_factura?: IntFieldUpdateOperationsInput | number
    id_orden?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metodo_pago?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type facturasCreateManyInput = {
    id_factura?: number
    id_orden: number
    fecha?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    metodo_pago?: string | null
    created_at?: Date | string | null
  }

  export type facturasUpdateManyMutationInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metodo_pago?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type facturasUncheckedUpdateManyInput = {
    id_factura?: IntFieldUpdateOperationsInput | number
    id_orden?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metodo_pago?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nombre?: SortOrder
    rol?: SortOrder
    activo?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nombre?: SortOrder
    rol?: SortOrder
    activo?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nombre?: SortOrder
    rol?: SortOrder
    activo?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type VehiculosListRelationFilter = {
    every?: vehiculosWhereInput
    some?: vehiculosWhereInput
    none?: vehiculosWhereInput
  }

  export type vehiculosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clientesCountOrderByAggregateInput = {
    id_cliente?: SortOrder
    nombre?: SortOrder
    direccion?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    created_at?: SortOrder
  }

  export type clientesAvgOrderByAggregateInput = {
    id_cliente?: SortOrder
  }

  export type clientesMaxOrderByAggregateInput = {
    id_cliente?: SortOrder
    nombre?: SortOrder
    direccion?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    created_at?: SortOrder
  }

  export type clientesMinOrderByAggregateInput = {
    id_cliente?: SortOrder
    nombre?: SortOrder
    direccion?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    created_at?: SortOrder
  }

  export type clientesSumOrderByAggregateInput = {
    id_cliente?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type ClientesRelationFilter = {
    is?: clientesWhereInput
    isNot?: clientesWhereInput
  }

  export type Ordenes_servicioListRelationFilter = {
    every?: ordenes_servicioWhereInput
    some?: ordenes_servicioWhereInput
    none?: ordenes_servicioWhereInput
  }

  export type ordenes_servicioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vehiculosCountOrderByAggregateInput = {
    id_vehiculo?: SortOrder
    id_cliente?: SortOrder
    marca?: SortOrder
    modelo?: SortOrder
    anio?: SortOrder
    placas?: SortOrder
    color?: SortOrder
    vin?: SortOrder
    created_at?: SortOrder
  }

  export type vehiculosAvgOrderByAggregateInput = {
    id_vehiculo?: SortOrder
    id_cliente?: SortOrder
    anio?: SortOrder
  }

  export type vehiculosMaxOrderByAggregateInput = {
    id_vehiculo?: SortOrder
    id_cliente?: SortOrder
    marca?: SortOrder
    modelo?: SortOrder
    anio?: SortOrder
    placas?: SortOrder
    color?: SortOrder
    vin?: SortOrder
    created_at?: SortOrder
  }

  export type vehiculosMinOrderByAggregateInput = {
    id_vehiculo?: SortOrder
    id_cliente?: SortOrder
    marca?: SortOrder
    modelo?: SortOrder
    anio?: SortOrder
    placas?: SortOrder
    color?: SortOrder
    vin?: SortOrder
    created_at?: SortOrder
  }

  export type vehiculosSumOrderByAggregateInput = {
    id_vehiculo?: SortOrder
    id_cliente?: SortOrder
    anio?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type Detalle_ordenListRelationFilter = {
    every?: detalle_ordenWhereInput
    some?: detalle_ordenWhereInput
    none?: detalle_ordenWhereInput
  }

  export type detalle_ordenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type serviciosCountOrderByAggregateInput = {
    id_servicio?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precio?: SortOrder
    tiempo_est?: SortOrder
    activo?: SortOrder
    created_at?: SortOrder
  }

  export type serviciosAvgOrderByAggregateInput = {
    id_servicio?: SortOrder
    precio?: SortOrder
    tiempo_est?: SortOrder
  }

  export type serviciosMaxOrderByAggregateInput = {
    id_servicio?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precio?: SortOrder
    tiempo_est?: SortOrder
    activo?: SortOrder
    created_at?: SortOrder
  }

  export type serviciosMinOrderByAggregateInput = {
    id_servicio?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precio?: SortOrder
    tiempo_est?: SortOrder
    activo?: SortOrder
    created_at?: SortOrder
  }

  export type serviciosSumOrderByAggregateInput = {
    id_servicio?: SortOrder
    precio?: SortOrder
    tiempo_est?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type empleadosCountOrderByAggregateInput = {
    id_empleado?: SortOrder
    nombre?: SortOrder
    especialidad?: SortOrder
    telefono?: SortOrder
    salario?: SortOrder
    activo?: SortOrder
    created_at?: SortOrder
  }

  export type empleadosAvgOrderByAggregateInput = {
    id_empleado?: SortOrder
    salario?: SortOrder
  }

  export type empleadosMaxOrderByAggregateInput = {
    id_empleado?: SortOrder
    nombre?: SortOrder
    especialidad?: SortOrder
    telefono?: SortOrder
    salario?: SortOrder
    activo?: SortOrder
    created_at?: SortOrder
  }

  export type empleadosMinOrderByAggregateInput = {
    id_empleado?: SortOrder
    nombre?: SortOrder
    especialidad?: SortOrder
    telefono?: SortOrder
    salario?: SortOrder
    activo?: SortOrder
    created_at?: SortOrder
  }

  export type empleadosSumOrderByAggregateInput = {
    id_empleado?: SortOrder
    salario?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type VehiculosRelationFilter = {
    is?: vehiculosWhereInput
    isNot?: vehiculosWhereInput
  }

  export type EmpleadosNullableRelationFilter = {
    is?: empleadosWhereInput | null
    isNot?: empleadosWhereInput | null
  }

  export type FacturasListRelationFilter = {
    every?: facturasWhereInput
    some?: facturasWhereInput
    none?: facturasWhereInput
  }

  export type facturasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ordenes_servicioCountOrderByAggregateInput = {
    id_orden?: SortOrder
    id_vehiculo?: SortOrder
    id_empleado?: SortOrder
    fecha_entrada?: SortOrder
    fecha_salida?: SortOrder
    observaciones?: SortOrder
    estado?: SortOrder
    kilometraje?: SortOrder
    created_at?: SortOrder
  }

  export type ordenes_servicioAvgOrderByAggregateInput = {
    id_orden?: SortOrder
    id_vehiculo?: SortOrder
    id_empleado?: SortOrder
    kilometraje?: SortOrder
  }

  export type ordenes_servicioMaxOrderByAggregateInput = {
    id_orden?: SortOrder
    id_vehiculo?: SortOrder
    id_empleado?: SortOrder
    fecha_entrada?: SortOrder
    fecha_salida?: SortOrder
    observaciones?: SortOrder
    estado?: SortOrder
    kilometraje?: SortOrder
    created_at?: SortOrder
  }

  export type ordenes_servicioMinOrderByAggregateInput = {
    id_orden?: SortOrder
    id_vehiculo?: SortOrder
    id_empleado?: SortOrder
    fecha_entrada?: SortOrder
    fecha_salida?: SortOrder
    observaciones?: SortOrder
    estado?: SortOrder
    kilometraje?: SortOrder
    created_at?: SortOrder
  }

  export type ordenes_servicioSumOrderByAggregateInput = {
    id_orden?: SortOrder
    id_vehiculo?: SortOrder
    id_empleado?: SortOrder
    kilometraje?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type Ordenes_servicioRelationFilter = {
    is?: ordenes_servicioWhereInput
    isNot?: ordenes_servicioWhereInput
  }

  export type ServiciosRelationFilter = {
    is?: serviciosWhereInput
    isNot?: serviciosWhereInput
  }

  export type detalle_ordenCountOrderByAggregateInput = {
    id_detalle?: SortOrder
    id_orden?: SortOrder
    id_servicio?: SortOrder
    cantidad?: SortOrder
    precio_unit?: SortOrder
    subtotal?: SortOrder
    created_at?: SortOrder
  }

  export type detalle_ordenAvgOrderByAggregateInput = {
    id_detalle?: SortOrder
    id_orden?: SortOrder
    id_servicio?: SortOrder
    cantidad?: SortOrder
    precio_unit?: SortOrder
    subtotal?: SortOrder
  }

  export type detalle_ordenMaxOrderByAggregateInput = {
    id_detalle?: SortOrder
    id_orden?: SortOrder
    id_servicio?: SortOrder
    cantidad?: SortOrder
    precio_unit?: SortOrder
    subtotal?: SortOrder
    created_at?: SortOrder
  }

  export type detalle_ordenMinOrderByAggregateInput = {
    id_detalle?: SortOrder
    id_orden?: SortOrder
    id_servicio?: SortOrder
    cantidad?: SortOrder
    precio_unit?: SortOrder
    subtotal?: SortOrder
    created_at?: SortOrder
  }

  export type detalle_ordenSumOrderByAggregateInput = {
    id_detalle?: SortOrder
    id_orden?: SortOrder
    id_servicio?: SortOrder
    cantidad?: SortOrder
    precio_unit?: SortOrder
    subtotal?: SortOrder
  }

  export type facturasCountOrderByAggregateInput = {
    id_factura?: SortOrder
    id_orden?: SortOrder
    fecha?: SortOrder
    subtotal?: SortOrder
    iva?: SortOrder
    total?: SortOrder
    metodo_pago?: SortOrder
    created_at?: SortOrder
  }

  export type facturasAvgOrderByAggregateInput = {
    id_factura?: SortOrder
    id_orden?: SortOrder
    subtotal?: SortOrder
    iva?: SortOrder
    total?: SortOrder
  }

  export type facturasMaxOrderByAggregateInput = {
    id_factura?: SortOrder
    id_orden?: SortOrder
    fecha?: SortOrder
    subtotal?: SortOrder
    iva?: SortOrder
    total?: SortOrder
    metodo_pago?: SortOrder
    created_at?: SortOrder
  }

  export type facturasMinOrderByAggregateInput = {
    id_factura?: SortOrder
    id_orden?: SortOrder
    fecha?: SortOrder
    subtotal?: SortOrder
    iva?: SortOrder
    total?: SortOrder
    metodo_pago?: SortOrder
    created_at?: SortOrder
  }

  export type facturasSumOrderByAggregateInput = {
    id_factura?: SortOrder
    id_orden?: SortOrder
    subtotal?: SortOrder
    iva?: SortOrder
    total?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type vehiculosCreateNestedManyWithoutClienteInput = {
    create?: XOR<vehiculosCreateWithoutClienteInput, vehiculosUncheckedCreateWithoutClienteInput> | vehiculosCreateWithoutClienteInput[] | vehiculosUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: vehiculosCreateOrConnectWithoutClienteInput | vehiculosCreateOrConnectWithoutClienteInput[]
    createMany?: vehiculosCreateManyClienteInputEnvelope
    connect?: vehiculosWhereUniqueInput | vehiculosWhereUniqueInput[]
  }

  export type vehiculosUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<vehiculosCreateWithoutClienteInput, vehiculosUncheckedCreateWithoutClienteInput> | vehiculosCreateWithoutClienteInput[] | vehiculosUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: vehiculosCreateOrConnectWithoutClienteInput | vehiculosCreateOrConnectWithoutClienteInput[]
    createMany?: vehiculosCreateManyClienteInputEnvelope
    connect?: vehiculosWhereUniqueInput | vehiculosWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type vehiculosUpdateManyWithoutClienteNestedInput = {
    create?: XOR<vehiculosCreateWithoutClienteInput, vehiculosUncheckedCreateWithoutClienteInput> | vehiculosCreateWithoutClienteInput[] | vehiculosUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: vehiculosCreateOrConnectWithoutClienteInput | vehiculosCreateOrConnectWithoutClienteInput[]
    upsert?: vehiculosUpsertWithWhereUniqueWithoutClienteInput | vehiculosUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: vehiculosCreateManyClienteInputEnvelope
    set?: vehiculosWhereUniqueInput | vehiculosWhereUniqueInput[]
    disconnect?: vehiculosWhereUniqueInput | vehiculosWhereUniqueInput[]
    delete?: vehiculosWhereUniqueInput | vehiculosWhereUniqueInput[]
    connect?: vehiculosWhereUniqueInput | vehiculosWhereUniqueInput[]
    update?: vehiculosUpdateWithWhereUniqueWithoutClienteInput | vehiculosUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: vehiculosUpdateManyWithWhereWithoutClienteInput | vehiculosUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: vehiculosScalarWhereInput | vehiculosScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type vehiculosUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<vehiculosCreateWithoutClienteInput, vehiculosUncheckedCreateWithoutClienteInput> | vehiculosCreateWithoutClienteInput[] | vehiculosUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: vehiculosCreateOrConnectWithoutClienteInput | vehiculosCreateOrConnectWithoutClienteInput[]
    upsert?: vehiculosUpsertWithWhereUniqueWithoutClienteInput | vehiculosUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: vehiculosCreateManyClienteInputEnvelope
    set?: vehiculosWhereUniqueInput | vehiculosWhereUniqueInput[]
    disconnect?: vehiculosWhereUniqueInput | vehiculosWhereUniqueInput[]
    delete?: vehiculosWhereUniqueInput | vehiculosWhereUniqueInput[]
    connect?: vehiculosWhereUniqueInput | vehiculosWhereUniqueInput[]
    update?: vehiculosUpdateWithWhereUniqueWithoutClienteInput | vehiculosUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: vehiculosUpdateManyWithWhereWithoutClienteInput | vehiculosUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: vehiculosScalarWhereInput | vehiculosScalarWhereInput[]
  }

  export type clientesCreateNestedOneWithoutVehiculosInput = {
    create?: XOR<clientesCreateWithoutVehiculosInput, clientesUncheckedCreateWithoutVehiculosInput>
    connectOrCreate?: clientesCreateOrConnectWithoutVehiculosInput
    connect?: clientesWhereUniqueInput
  }

  export type ordenes_servicioCreateNestedManyWithoutVehiculoInput = {
    create?: XOR<ordenes_servicioCreateWithoutVehiculoInput, ordenes_servicioUncheckedCreateWithoutVehiculoInput> | ordenes_servicioCreateWithoutVehiculoInput[] | ordenes_servicioUncheckedCreateWithoutVehiculoInput[]
    connectOrCreate?: ordenes_servicioCreateOrConnectWithoutVehiculoInput | ordenes_servicioCreateOrConnectWithoutVehiculoInput[]
    createMany?: ordenes_servicioCreateManyVehiculoInputEnvelope
    connect?: ordenes_servicioWhereUniqueInput | ordenes_servicioWhereUniqueInput[]
  }

  export type ordenes_servicioUncheckedCreateNestedManyWithoutVehiculoInput = {
    create?: XOR<ordenes_servicioCreateWithoutVehiculoInput, ordenes_servicioUncheckedCreateWithoutVehiculoInput> | ordenes_servicioCreateWithoutVehiculoInput[] | ordenes_servicioUncheckedCreateWithoutVehiculoInput[]
    connectOrCreate?: ordenes_servicioCreateOrConnectWithoutVehiculoInput | ordenes_servicioCreateOrConnectWithoutVehiculoInput[]
    createMany?: ordenes_servicioCreateManyVehiculoInputEnvelope
    connect?: ordenes_servicioWhereUniqueInput | ordenes_servicioWhereUniqueInput[]
  }

  export type clientesUpdateOneRequiredWithoutVehiculosNestedInput = {
    create?: XOR<clientesCreateWithoutVehiculosInput, clientesUncheckedCreateWithoutVehiculosInput>
    connectOrCreate?: clientesCreateOrConnectWithoutVehiculosInput
    upsert?: clientesUpsertWithoutVehiculosInput
    connect?: clientesWhereUniqueInput
    update?: XOR<XOR<clientesUpdateToOneWithWhereWithoutVehiculosInput, clientesUpdateWithoutVehiculosInput>, clientesUncheckedUpdateWithoutVehiculosInput>
  }

  export type ordenes_servicioUpdateManyWithoutVehiculoNestedInput = {
    create?: XOR<ordenes_servicioCreateWithoutVehiculoInput, ordenes_servicioUncheckedCreateWithoutVehiculoInput> | ordenes_servicioCreateWithoutVehiculoInput[] | ordenes_servicioUncheckedCreateWithoutVehiculoInput[]
    connectOrCreate?: ordenes_servicioCreateOrConnectWithoutVehiculoInput | ordenes_servicioCreateOrConnectWithoutVehiculoInput[]
    upsert?: ordenes_servicioUpsertWithWhereUniqueWithoutVehiculoInput | ordenes_servicioUpsertWithWhereUniqueWithoutVehiculoInput[]
    createMany?: ordenes_servicioCreateManyVehiculoInputEnvelope
    set?: ordenes_servicioWhereUniqueInput | ordenes_servicioWhereUniqueInput[]
    disconnect?: ordenes_servicioWhereUniqueInput | ordenes_servicioWhereUniqueInput[]
    delete?: ordenes_servicioWhereUniqueInput | ordenes_servicioWhereUniqueInput[]
    connect?: ordenes_servicioWhereUniqueInput | ordenes_servicioWhereUniqueInput[]
    update?: ordenes_servicioUpdateWithWhereUniqueWithoutVehiculoInput | ordenes_servicioUpdateWithWhereUniqueWithoutVehiculoInput[]
    updateMany?: ordenes_servicioUpdateManyWithWhereWithoutVehiculoInput | ordenes_servicioUpdateManyWithWhereWithoutVehiculoInput[]
    deleteMany?: ordenes_servicioScalarWhereInput | ordenes_servicioScalarWhereInput[]
  }

  export type ordenes_servicioUncheckedUpdateManyWithoutVehiculoNestedInput = {
    create?: XOR<ordenes_servicioCreateWithoutVehiculoInput, ordenes_servicioUncheckedCreateWithoutVehiculoInput> | ordenes_servicioCreateWithoutVehiculoInput[] | ordenes_servicioUncheckedCreateWithoutVehiculoInput[]
    connectOrCreate?: ordenes_servicioCreateOrConnectWithoutVehiculoInput | ordenes_servicioCreateOrConnectWithoutVehiculoInput[]
    upsert?: ordenes_servicioUpsertWithWhereUniqueWithoutVehiculoInput | ordenes_servicioUpsertWithWhereUniqueWithoutVehiculoInput[]
    createMany?: ordenes_servicioCreateManyVehiculoInputEnvelope
    set?: ordenes_servicioWhereUniqueInput | ordenes_servicioWhereUniqueInput[]
    disconnect?: ordenes_servicioWhereUniqueInput | ordenes_servicioWhereUniqueInput[]
    delete?: ordenes_servicioWhereUniqueInput | ordenes_servicioWhereUniqueInput[]
    connect?: ordenes_servicioWhereUniqueInput | ordenes_servicioWhereUniqueInput[]
    update?: ordenes_servicioUpdateWithWhereUniqueWithoutVehiculoInput | ordenes_servicioUpdateWithWhereUniqueWithoutVehiculoInput[]
    updateMany?: ordenes_servicioUpdateManyWithWhereWithoutVehiculoInput | ordenes_servicioUpdateManyWithWhereWithoutVehiculoInput[]
    deleteMany?: ordenes_servicioScalarWhereInput | ordenes_servicioScalarWhereInput[]
  }

  export type detalle_ordenCreateNestedManyWithoutServicioInput = {
    create?: XOR<detalle_ordenCreateWithoutServicioInput, detalle_ordenUncheckedCreateWithoutServicioInput> | detalle_ordenCreateWithoutServicioInput[] | detalle_ordenUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: detalle_ordenCreateOrConnectWithoutServicioInput | detalle_ordenCreateOrConnectWithoutServicioInput[]
    createMany?: detalle_ordenCreateManyServicioInputEnvelope
    connect?: detalle_ordenWhereUniqueInput | detalle_ordenWhereUniqueInput[]
  }

  export type detalle_ordenUncheckedCreateNestedManyWithoutServicioInput = {
    create?: XOR<detalle_ordenCreateWithoutServicioInput, detalle_ordenUncheckedCreateWithoutServicioInput> | detalle_ordenCreateWithoutServicioInput[] | detalle_ordenUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: detalle_ordenCreateOrConnectWithoutServicioInput | detalle_ordenCreateOrConnectWithoutServicioInput[]
    createMany?: detalle_ordenCreateManyServicioInputEnvelope
    connect?: detalle_ordenWhereUniqueInput | detalle_ordenWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type detalle_ordenUpdateManyWithoutServicioNestedInput = {
    create?: XOR<detalle_ordenCreateWithoutServicioInput, detalle_ordenUncheckedCreateWithoutServicioInput> | detalle_ordenCreateWithoutServicioInput[] | detalle_ordenUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: detalle_ordenCreateOrConnectWithoutServicioInput | detalle_ordenCreateOrConnectWithoutServicioInput[]
    upsert?: detalle_ordenUpsertWithWhereUniqueWithoutServicioInput | detalle_ordenUpsertWithWhereUniqueWithoutServicioInput[]
    createMany?: detalle_ordenCreateManyServicioInputEnvelope
    set?: detalle_ordenWhereUniqueInput | detalle_ordenWhereUniqueInput[]
    disconnect?: detalle_ordenWhereUniqueInput | detalle_ordenWhereUniqueInput[]
    delete?: detalle_ordenWhereUniqueInput | detalle_ordenWhereUniqueInput[]
    connect?: detalle_ordenWhereUniqueInput | detalle_ordenWhereUniqueInput[]
    update?: detalle_ordenUpdateWithWhereUniqueWithoutServicioInput | detalle_ordenUpdateWithWhereUniqueWithoutServicioInput[]
    updateMany?: detalle_ordenUpdateManyWithWhereWithoutServicioInput | detalle_ordenUpdateManyWithWhereWithoutServicioInput[]
    deleteMany?: detalle_ordenScalarWhereInput | detalle_ordenScalarWhereInput[]
  }

  export type detalle_ordenUncheckedUpdateManyWithoutServicioNestedInput = {
    create?: XOR<detalle_ordenCreateWithoutServicioInput, detalle_ordenUncheckedCreateWithoutServicioInput> | detalle_ordenCreateWithoutServicioInput[] | detalle_ordenUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: detalle_ordenCreateOrConnectWithoutServicioInput | detalle_ordenCreateOrConnectWithoutServicioInput[]
    upsert?: detalle_ordenUpsertWithWhereUniqueWithoutServicioInput | detalle_ordenUpsertWithWhereUniqueWithoutServicioInput[]
    createMany?: detalle_ordenCreateManyServicioInputEnvelope
    set?: detalle_ordenWhereUniqueInput | detalle_ordenWhereUniqueInput[]
    disconnect?: detalle_ordenWhereUniqueInput | detalle_ordenWhereUniqueInput[]
    delete?: detalle_ordenWhereUniqueInput | detalle_ordenWhereUniqueInput[]
    connect?: detalle_ordenWhereUniqueInput | detalle_ordenWhereUniqueInput[]
    update?: detalle_ordenUpdateWithWhereUniqueWithoutServicioInput | detalle_ordenUpdateWithWhereUniqueWithoutServicioInput[]
    updateMany?: detalle_ordenUpdateManyWithWhereWithoutServicioInput | detalle_ordenUpdateManyWithWhereWithoutServicioInput[]
    deleteMany?: detalle_ordenScalarWhereInput | detalle_ordenScalarWhereInput[]
  }

  export type ordenes_servicioCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<ordenes_servicioCreateWithoutEmpleadoInput, ordenes_servicioUncheckedCreateWithoutEmpleadoInput> | ordenes_servicioCreateWithoutEmpleadoInput[] | ordenes_servicioUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: ordenes_servicioCreateOrConnectWithoutEmpleadoInput | ordenes_servicioCreateOrConnectWithoutEmpleadoInput[]
    createMany?: ordenes_servicioCreateManyEmpleadoInputEnvelope
    connect?: ordenes_servicioWhereUniqueInput | ordenes_servicioWhereUniqueInput[]
  }

  export type ordenes_servicioUncheckedCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<ordenes_servicioCreateWithoutEmpleadoInput, ordenes_servicioUncheckedCreateWithoutEmpleadoInput> | ordenes_servicioCreateWithoutEmpleadoInput[] | ordenes_servicioUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: ordenes_servicioCreateOrConnectWithoutEmpleadoInput | ordenes_servicioCreateOrConnectWithoutEmpleadoInput[]
    createMany?: ordenes_servicioCreateManyEmpleadoInputEnvelope
    connect?: ordenes_servicioWhereUniqueInput | ordenes_servicioWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ordenes_servicioUpdateManyWithoutEmpleadoNestedInput = {
    create?: XOR<ordenes_servicioCreateWithoutEmpleadoInput, ordenes_servicioUncheckedCreateWithoutEmpleadoInput> | ordenes_servicioCreateWithoutEmpleadoInput[] | ordenes_servicioUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: ordenes_servicioCreateOrConnectWithoutEmpleadoInput | ordenes_servicioCreateOrConnectWithoutEmpleadoInput[]
    upsert?: ordenes_servicioUpsertWithWhereUniqueWithoutEmpleadoInput | ordenes_servicioUpsertWithWhereUniqueWithoutEmpleadoInput[]
    createMany?: ordenes_servicioCreateManyEmpleadoInputEnvelope
    set?: ordenes_servicioWhereUniqueInput | ordenes_servicioWhereUniqueInput[]
    disconnect?: ordenes_servicioWhereUniqueInput | ordenes_servicioWhereUniqueInput[]
    delete?: ordenes_servicioWhereUniqueInput | ordenes_servicioWhereUniqueInput[]
    connect?: ordenes_servicioWhereUniqueInput | ordenes_servicioWhereUniqueInput[]
    update?: ordenes_servicioUpdateWithWhereUniqueWithoutEmpleadoInput | ordenes_servicioUpdateWithWhereUniqueWithoutEmpleadoInput[]
    updateMany?: ordenes_servicioUpdateManyWithWhereWithoutEmpleadoInput | ordenes_servicioUpdateManyWithWhereWithoutEmpleadoInput[]
    deleteMany?: ordenes_servicioScalarWhereInput | ordenes_servicioScalarWhereInput[]
  }

  export type ordenes_servicioUncheckedUpdateManyWithoutEmpleadoNestedInput = {
    create?: XOR<ordenes_servicioCreateWithoutEmpleadoInput, ordenes_servicioUncheckedCreateWithoutEmpleadoInput> | ordenes_servicioCreateWithoutEmpleadoInput[] | ordenes_servicioUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: ordenes_servicioCreateOrConnectWithoutEmpleadoInput | ordenes_servicioCreateOrConnectWithoutEmpleadoInput[]
    upsert?: ordenes_servicioUpsertWithWhereUniqueWithoutEmpleadoInput | ordenes_servicioUpsertWithWhereUniqueWithoutEmpleadoInput[]
    createMany?: ordenes_servicioCreateManyEmpleadoInputEnvelope
    set?: ordenes_servicioWhereUniqueInput | ordenes_servicioWhereUniqueInput[]
    disconnect?: ordenes_servicioWhereUniqueInput | ordenes_servicioWhereUniqueInput[]
    delete?: ordenes_servicioWhereUniqueInput | ordenes_servicioWhereUniqueInput[]
    connect?: ordenes_servicioWhereUniqueInput | ordenes_servicioWhereUniqueInput[]
    update?: ordenes_servicioUpdateWithWhereUniqueWithoutEmpleadoInput | ordenes_servicioUpdateWithWhereUniqueWithoutEmpleadoInput[]
    updateMany?: ordenes_servicioUpdateManyWithWhereWithoutEmpleadoInput | ordenes_servicioUpdateManyWithWhereWithoutEmpleadoInput[]
    deleteMany?: ordenes_servicioScalarWhereInput | ordenes_servicioScalarWhereInput[]
  }

  export type vehiculosCreateNestedOneWithoutOrdenes_servicioInput = {
    create?: XOR<vehiculosCreateWithoutOrdenes_servicioInput, vehiculosUncheckedCreateWithoutOrdenes_servicioInput>
    connectOrCreate?: vehiculosCreateOrConnectWithoutOrdenes_servicioInput
    connect?: vehiculosWhereUniqueInput
  }

  export type empleadosCreateNestedOneWithoutOrdenes_servicioInput = {
    create?: XOR<empleadosCreateWithoutOrdenes_servicioInput, empleadosUncheckedCreateWithoutOrdenes_servicioInput>
    connectOrCreate?: empleadosCreateOrConnectWithoutOrdenes_servicioInput
    connect?: empleadosWhereUniqueInput
  }

  export type detalle_ordenCreateNestedManyWithoutOrdenInput = {
    create?: XOR<detalle_ordenCreateWithoutOrdenInput, detalle_ordenUncheckedCreateWithoutOrdenInput> | detalle_ordenCreateWithoutOrdenInput[] | detalle_ordenUncheckedCreateWithoutOrdenInput[]
    connectOrCreate?: detalle_ordenCreateOrConnectWithoutOrdenInput | detalle_ordenCreateOrConnectWithoutOrdenInput[]
    createMany?: detalle_ordenCreateManyOrdenInputEnvelope
    connect?: detalle_ordenWhereUniqueInput | detalle_ordenWhereUniqueInput[]
  }

  export type facturasCreateNestedManyWithoutOrdenInput = {
    create?: XOR<facturasCreateWithoutOrdenInput, facturasUncheckedCreateWithoutOrdenInput> | facturasCreateWithoutOrdenInput[] | facturasUncheckedCreateWithoutOrdenInput[]
    connectOrCreate?: facturasCreateOrConnectWithoutOrdenInput | facturasCreateOrConnectWithoutOrdenInput[]
    createMany?: facturasCreateManyOrdenInputEnvelope
    connect?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
  }

  export type detalle_ordenUncheckedCreateNestedManyWithoutOrdenInput = {
    create?: XOR<detalle_ordenCreateWithoutOrdenInput, detalle_ordenUncheckedCreateWithoutOrdenInput> | detalle_ordenCreateWithoutOrdenInput[] | detalle_ordenUncheckedCreateWithoutOrdenInput[]
    connectOrCreate?: detalle_ordenCreateOrConnectWithoutOrdenInput | detalle_ordenCreateOrConnectWithoutOrdenInput[]
    createMany?: detalle_ordenCreateManyOrdenInputEnvelope
    connect?: detalle_ordenWhereUniqueInput | detalle_ordenWhereUniqueInput[]
  }

  export type facturasUncheckedCreateNestedManyWithoutOrdenInput = {
    create?: XOR<facturasCreateWithoutOrdenInput, facturasUncheckedCreateWithoutOrdenInput> | facturasCreateWithoutOrdenInput[] | facturasUncheckedCreateWithoutOrdenInput[]
    connectOrCreate?: facturasCreateOrConnectWithoutOrdenInput | facturasCreateOrConnectWithoutOrdenInput[]
    createMany?: facturasCreateManyOrdenInputEnvelope
    connect?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type vehiculosUpdateOneRequiredWithoutOrdenes_servicioNestedInput = {
    create?: XOR<vehiculosCreateWithoutOrdenes_servicioInput, vehiculosUncheckedCreateWithoutOrdenes_servicioInput>
    connectOrCreate?: vehiculosCreateOrConnectWithoutOrdenes_servicioInput
    upsert?: vehiculosUpsertWithoutOrdenes_servicioInput
    connect?: vehiculosWhereUniqueInput
    update?: XOR<XOR<vehiculosUpdateToOneWithWhereWithoutOrdenes_servicioInput, vehiculosUpdateWithoutOrdenes_servicioInput>, vehiculosUncheckedUpdateWithoutOrdenes_servicioInput>
  }

  export type empleadosUpdateOneWithoutOrdenes_servicioNestedInput = {
    create?: XOR<empleadosCreateWithoutOrdenes_servicioInput, empleadosUncheckedCreateWithoutOrdenes_servicioInput>
    connectOrCreate?: empleadosCreateOrConnectWithoutOrdenes_servicioInput
    upsert?: empleadosUpsertWithoutOrdenes_servicioInput
    disconnect?: empleadosWhereInput | boolean
    delete?: empleadosWhereInput | boolean
    connect?: empleadosWhereUniqueInput
    update?: XOR<XOR<empleadosUpdateToOneWithWhereWithoutOrdenes_servicioInput, empleadosUpdateWithoutOrdenes_servicioInput>, empleadosUncheckedUpdateWithoutOrdenes_servicioInput>
  }

  export type detalle_ordenUpdateManyWithoutOrdenNestedInput = {
    create?: XOR<detalle_ordenCreateWithoutOrdenInput, detalle_ordenUncheckedCreateWithoutOrdenInput> | detalle_ordenCreateWithoutOrdenInput[] | detalle_ordenUncheckedCreateWithoutOrdenInput[]
    connectOrCreate?: detalle_ordenCreateOrConnectWithoutOrdenInput | detalle_ordenCreateOrConnectWithoutOrdenInput[]
    upsert?: detalle_ordenUpsertWithWhereUniqueWithoutOrdenInput | detalle_ordenUpsertWithWhereUniqueWithoutOrdenInput[]
    createMany?: detalle_ordenCreateManyOrdenInputEnvelope
    set?: detalle_ordenWhereUniqueInput | detalle_ordenWhereUniqueInput[]
    disconnect?: detalle_ordenWhereUniqueInput | detalle_ordenWhereUniqueInput[]
    delete?: detalle_ordenWhereUniqueInput | detalle_ordenWhereUniqueInput[]
    connect?: detalle_ordenWhereUniqueInput | detalle_ordenWhereUniqueInput[]
    update?: detalle_ordenUpdateWithWhereUniqueWithoutOrdenInput | detalle_ordenUpdateWithWhereUniqueWithoutOrdenInput[]
    updateMany?: detalle_ordenUpdateManyWithWhereWithoutOrdenInput | detalle_ordenUpdateManyWithWhereWithoutOrdenInput[]
    deleteMany?: detalle_ordenScalarWhereInput | detalle_ordenScalarWhereInput[]
  }

  export type facturasUpdateManyWithoutOrdenNestedInput = {
    create?: XOR<facturasCreateWithoutOrdenInput, facturasUncheckedCreateWithoutOrdenInput> | facturasCreateWithoutOrdenInput[] | facturasUncheckedCreateWithoutOrdenInput[]
    connectOrCreate?: facturasCreateOrConnectWithoutOrdenInput | facturasCreateOrConnectWithoutOrdenInput[]
    upsert?: facturasUpsertWithWhereUniqueWithoutOrdenInput | facturasUpsertWithWhereUniqueWithoutOrdenInput[]
    createMany?: facturasCreateManyOrdenInputEnvelope
    set?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    disconnect?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    delete?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    connect?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    update?: facturasUpdateWithWhereUniqueWithoutOrdenInput | facturasUpdateWithWhereUniqueWithoutOrdenInput[]
    updateMany?: facturasUpdateManyWithWhereWithoutOrdenInput | facturasUpdateManyWithWhereWithoutOrdenInput[]
    deleteMany?: facturasScalarWhereInput | facturasScalarWhereInput[]
  }

  export type detalle_ordenUncheckedUpdateManyWithoutOrdenNestedInput = {
    create?: XOR<detalle_ordenCreateWithoutOrdenInput, detalle_ordenUncheckedCreateWithoutOrdenInput> | detalle_ordenCreateWithoutOrdenInput[] | detalle_ordenUncheckedCreateWithoutOrdenInput[]
    connectOrCreate?: detalle_ordenCreateOrConnectWithoutOrdenInput | detalle_ordenCreateOrConnectWithoutOrdenInput[]
    upsert?: detalle_ordenUpsertWithWhereUniqueWithoutOrdenInput | detalle_ordenUpsertWithWhereUniqueWithoutOrdenInput[]
    createMany?: detalle_ordenCreateManyOrdenInputEnvelope
    set?: detalle_ordenWhereUniqueInput | detalle_ordenWhereUniqueInput[]
    disconnect?: detalle_ordenWhereUniqueInput | detalle_ordenWhereUniqueInput[]
    delete?: detalle_ordenWhereUniqueInput | detalle_ordenWhereUniqueInput[]
    connect?: detalle_ordenWhereUniqueInput | detalle_ordenWhereUniqueInput[]
    update?: detalle_ordenUpdateWithWhereUniqueWithoutOrdenInput | detalle_ordenUpdateWithWhereUniqueWithoutOrdenInput[]
    updateMany?: detalle_ordenUpdateManyWithWhereWithoutOrdenInput | detalle_ordenUpdateManyWithWhereWithoutOrdenInput[]
    deleteMany?: detalle_ordenScalarWhereInput | detalle_ordenScalarWhereInput[]
  }

  export type facturasUncheckedUpdateManyWithoutOrdenNestedInput = {
    create?: XOR<facturasCreateWithoutOrdenInput, facturasUncheckedCreateWithoutOrdenInput> | facturasCreateWithoutOrdenInput[] | facturasUncheckedCreateWithoutOrdenInput[]
    connectOrCreate?: facturasCreateOrConnectWithoutOrdenInput | facturasCreateOrConnectWithoutOrdenInput[]
    upsert?: facturasUpsertWithWhereUniqueWithoutOrdenInput | facturasUpsertWithWhereUniqueWithoutOrdenInput[]
    createMany?: facturasCreateManyOrdenInputEnvelope
    set?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    disconnect?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    delete?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    connect?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    update?: facturasUpdateWithWhereUniqueWithoutOrdenInput | facturasUpdateWithWhereUniqueWithoutOrdenInput[]
    updateMany?: facturasUpdateManyWithWhereWithoutOrdenInput | facturasUpdateManyWithWhereWithoutOrdenInput[]
    deleteMany?: facturasScalarWhereInput | facturasScalarWhereInput[]
  }

  export type ordenes_servicioCreateNestedOneWithoutDetalle_ordenInput = {
    create?: XOR<ordenes_servicioCreateWithoutDetalle_ordenInput, ordenes_servicioUncheckedCreateWithoutDetalle_ordenInput>
    connectOrCreate?: ordenes_servicioCreateOrConnectWithoutDetalle_ordenInput
    connect?: ordenes_servicioWhereUniqueInput
  }

  export type serviciosCreateNestedOneWithoutDetalle_ordenInput = {
    create?: XOR<serviciosCreateWithoutDetalle_ordenInput, serviciosUncheckedCreateWithoutDetalle_ordenInput>
    connectOrCreate?: serviciosCreateOrConnectWithoutDetalle_ordenInput
    connect?: serviciosWhereUniqueInput
  }

  export type ordenes_servicioUpdateOneRequiredWithoutDetalle_ordenNestedInput = {
    create?: XOR<ordenes_servicioCreateWithoutDetalle_ordenInput, ordenes_servicioUncheckedCreateWithoutDetalle_ordenInput>
    connectOrCreate?: ordenes_servicioCreateOrConnectWithoutDetalle_ordenInput
    upsert?: ordenes_servicioUpsertWithoutDetalle_ordenInput
    connect?: ordenes_servicioWhereUniqueInput
    update?: XOR<XOR<ordenes_servicioUpdateToOneWithWhereWithoutDetalle_ordenInput, ordenes_servicioUpdateWithoutDetalle_ordenInput>, ordenes_servicioUncheckedUpdateWithoutDetalle_ordenInput>
  }

  export type serviciosUpdateOneRequiredWithoutDetalle_ordenNestedInput = {
    create?: XOR<serviciosCreateWithoutDetalle_ordenInput, serviciosUncheckedCreateWithoutDetalle_ordenInput>
    connectOrCreate?: serviciosCreateOrConnectWithoutDetalle_ordenInput
    upsert?: serviciosUpsertWithoutDetalle_ordenInput
    connect?: serviciosWhereUniqueInput
    update?: XOR<XOR<serviciosUpdateToOneWithWhereWithoutDetalle_ordenInput, serviciosUpdateWithoutDetalle_ordenInput>, serviciosUncheckedUpdateWithoutDetalle_ordenInput>
  }

  export type ordenes_servicioCreateNestedOneWithoutFacturasInput = {
    create?: XOR<ordenes_servicioCreateWithoutFacturasInput, ordenes_servicioUncheckedCreateWithoutFacturasInput>
    connectOrCreate?: ordenes_servicioCreateOrConnectWithoutFacturasInput
    connect?: ordenes_servicioWhereUniqueInput
  }

  export type ordenes_servicioUpdateOneRequiredWithoutFacturasNestedInput = {
    create?: XOR<ordenes_servicioCreateWithoutFacturasInput, ordenes_servicioUncheckedCreateWithoutFacturasInput>
    connectOrCreate?: ordenes_servicioCreateOrConnectWithoutFacturasInput
    upsert?: ordenes_servicioUpsertWithoutFacturasInput
    connect?: ordenes_servicioWhereUniqueInput
    update?: XOR<XOR<ordenes_servicioUpdateToOneWithWhereWithoutFacturasInput, ordenes_servicioUpdateWithoutFacturasInput>, ordenes_servicioUncheckedUpdateWithoutFacturasInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type vehiculosCreateWithoutClienteInput = {
    marca: string
    modelo: string
    anio: number
    placas: string
    color?: string | null
    vin?: string | null
    created_at?: Date | string | null
    ordenes_servicio?: ordenes_servicioCreateNestedManyWithoutVehiculoInput
  }

  export type vehiculosUncheckedCreateWithoutClienteInput = {
    id_vehiculo?: number
    marca: string
    modelo: string
    anio: number
    placas: string
    color?: string | null
    vin?: string | null
    created_at?: Date | string | null
    ordenes_servicio?: ordenes_servicioUncheckedCreateNestedManyWithoutVehiculoInput
  }

  export type vehiculosCreateOrConnectWithoutClienteInput = {
    where: vehiculosWhereUniqueInput
    create: XOR<vehiculosCreateWithoutClienteInput, vehiculosUncheckedCreateWithoutClienteInput>
  }

  export type vehiculosCreateManyClienteInputEnvelope = {
    data: vehiculosCreateManyClienteInput | vehiculosCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type vehiculosUpsertWithWhereUniqueWithoutClienteInput = {
    where: vehiculosWhereUniqueInput
    update: XOR<vehiculosUpdateWithoutClienteInput, vehiculosUncheckedUpdateWithoutClienteInput>
    create: XOR<vehiculosCreateWithoutClienteInput, vehiculosUncheckedCreateWithoutClienteInput>
  }

  export type vehiculosUpdateWithWhereUniqueWithoutClienteInput = {
    where: vehiculosWhereUniqueInput
    data: XOR<vehiculosUpdateWithoutClienteInput, vehiculosUncheckedUpdateWithoutClienteInput>
  }

  export type vehiculosUpdateManyWithWhereWithoutClienteInput = {
    where: vehiculosScalarWhereInput
    data: XOR<vehiculosUpdateManyMutationInput, vehiculosUncheckedUpdateManyWithoutClienteInput>
  }

  export type vehiculosScalarWhereInput = {
    AND?: vehiculosScalarWhereInput | vehiculosScalarWhereInput[]
    OR?: vehiculosScalarWhereInput[]
    NOT?: vehiculosScalarWhereInput | vehiculosScalarWhereInput[]
    id_vehiculo?: IntFilter<"vehiculos"> | number
    id_cliente?: IntFilter<"vehiculos"> | number
    marca?: StringFilter<"vehiculos"> | string
    modelo?: StringFilter<"vehiculos"> | string
    anio?: IntFilter<"vehiculos"> | number
    placas?: StringFilter<"vehiculos"> | string
    color?: StringNullableFilter<"vehiculos"> | string | null
    vin?: StringNullableFilter<"vehiculos"> | string | null
    created_at?: DateTimeNullableFilter<"vehiculos"> | Date | string | null
  }

  export type clientesCreateWithoutVehiculosInput = {
    nombre: string
    direccion?: string | null
    telefono: string
    correo?: string | null
    created_at?: Date | string | null
  }

  export type clientesUncheckedCreateWithoutVehiculosInput = {
    id_cliente?: number
    nombre: string
    direccion?: string | null
    telefono: string
    correo?: string | null
    created_at?: Date | string | null
  }

  export type clientesCreateOrConnectWithoutVehiculosInput = {
    where: clientesWhereUniqueInput
    create: XOR<clientesCreateWithoutVehiculosInput, clientesUncheckedCreateWithoutVehiculosInput>
  }

  export type ordenes_servicioCreateWithoutVehiculoInput = {
    fecha_entrada?: Date | string
    fecha_salida?: Date | string | null
    observaciones?: string | null
    estado?: string
    kilometraje?: number | null
    created_at?: Date | string | null
    empleado?: empleadosCreateNestedOneWithoutOrdenes_servicioInput
    detalle_orden?: detalle_ordenCreateNestedManyWithoutOrdenInput
    facturas?: facturasCreateNestedManyWithoutOrdenInput
  }

  export type ordenes_servicioUncheckedCreateWithoutVehiculoInput = {
    id_orden?: number
    id_empleado?: number | null
    fecha_entrada?: Date | string
    fecha_salida?: Date | string | null
    observaciones?: string | null
    estado?: string
    kilometraje?: number | null
    created_at?: Date | string | null
    detalle_orden?: detalle_ordenUncheckedCreateNestedManyWithoutOrdenInput
    facturas?: facturasUncheckedCreateNestedManyWithoutOrdenInput
  }

  export type ordenes_servicioCreateOrConnectWithoutVehiculoInput = {
    where: ordenes_servicioWhereUniqueInput
    create: XOR<ordenes_servicioCreateWithoutVehiculoInput, ordenes_servicioUncheckedCreateWithoutVehiculoInput>
  }

  export type ordenes_servicioCreateManyVehiculoInputEnvelope = {
    data: ordenes_servicioCreateManyVehiculoInput | ordenes_servicioCreateManyVehiculoInput[]
    skipDuplicates?: boolean
  }

  export type clientesUpsertWithoutVehiculosInput = {
    update: XOR<clientesUpdateWithoutVehiculosInput, clientesUncheckedUpdateWithoutVehiculosInput>
    create: XOR<clientesCreateWithoutVehiculosInput, clientesUncheckedCreateWithoutVehiculosInput>
    where?: clientesWhereInput
  }

  export type clientesUpdateToOneWithWhereWithoutVehiculosInput = {
    where?: clientesWhereInput
    data: XOR<clientesUpdateWithoutVehiculosInput, clientesUncheckedUpdateWithoutVehiculosInput>
  }

  export type clientesUpdateWithoutVehiculosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type clientesUncheckedUpdateWithoutVehiculosInput = {
    id_cliente?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ordenes_servicioUpsertWithWhereUniqueWithoutVehiculoInput = {
    where: ordenes_servicioWhereUniqueInput
    update: XOR<ordenes_servicioUpdateWithoutVehiculoInput, ordenes_servicioUncheckedUpdateWithoutVehiculoInput>
    create: XOR<ordenes_servicioCreateWithoutVehiculoInput, ordenes_servicioUncheckedCreateWithoutVehiculoInput>
  }

  export type ordenes_servicioUpdateWithWhereUniqueWithoutVehiculoInput = {
    where: ordenes_servicioWhereUniqueInput
    data: XOR<ordenes_servicioUpdateWithoutVehiculoInput, ordenes_servicioUncheckedUpdateWithoutVehiculoInput>
  }

  export type ordenes_servicioUpdateManyWithWhereWithoutVehiculoInput = {
    where: ordenes_servicioScalarWhereInput
    data: XOR<ordenes_servicioUpdateManyMutationInput, ordenes_servicioUncheckedUpdateManyWithoutVehiculoInput>
  }

  export type ordenes_servicioScalarWhereInput = {
    AND?: ordenes_servicioScalarWhereInput | ordenes_servicioScalarWhereInput[]
    OR?: ordenes_servicioScalarWhereInput[]
    NOT?: ordenes_servicioScalarWhereInput | ordenes_servicioScalarWhereInput[]
    id_orden?: IntFilter<"ordenes_servicio"> | number
    id_vehiculo?: IntFilter<"ordenes_servicio"> | number
    id_empleado?: IntNullableFilter<"ordenes_servicio"> | number | null
    fecha_entrada?: DateTimeFilter<"ordenes_servicio"> | Date | string
    fecha_salida?: DateTimeNullableFilter<"ordenes_servicio"> | Date | string | null
    observaciones?: StringNullableFilter<"ordenes_servicio"> | string | null
    estado?: StringFilter<"ordenes_servicio"> | string
    kilometraje?: IntNullableFilter<"ordenes_servicio"> | number | null
    created_at?: DateTimeNullableFilter<"ordenes_servicio"> | Date | string | null
  }

  export type detalle_ordenCreateWithoutServicioInput = {
    cantidad?: number
    precio_unit: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    orden: ordenes_servicioCreateNestedOneWithoutDetalle_ordenInput
  }

  export type detalle_ordenUncheckedCreateWithoutServicioInput = {
    id_detalle?: number
    id_orden: number
    cantidad?: number
    precio_unit: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
  }

  export type detalle_ordenCreateOrConnectWithoutServicioInput = {
    where: detalle_ordenWhereUniqueInput
    create: XOR<detalle_ordenCreateWithoutServicioInput, detalle_ordenUncheckedCreateWithoutServicioInput>
  }

  export type detalle_ordenCreateManyServicioInputEnvelope = {
    data: detalle_ordenCreateManyServicioInput | detalle_ordenCreateManyServicioInput[]
    skipDuplicates?: boolean
  }

  export type detalle_ordenUpsertWithWhereUniqueWithoutServicioInput = {
    where: detalle_ordenWhereUniqueInput
    update: XOR<detalle_ordenUpdateWithoutServicioInput, detalle_ordenUncheckedUpdateWithoutServicioInput>
    create: XOR<detalle_ordenCreateWithoutServicioInput, detalle_ordenUncheckedCreateWithoutServicioInput>
  }

  export type detalle_ordenUpdateWithWhereUniqueWithoutServicioInput = {
    where: detalle_ordenWhereUniqueInput
    data: XOR<detalle_ordenUpdateWithoutServicioInput, detalle_ordenUncheckedUpdateWithoutServicioInput>
  }

  export type detalle_ordenUpdateManyWithWhereWithoutServicioInput = {
    where: detalle_ordenScalarWhereInput
    data: XOR<detalle_ordenUpdateManyMutationInput, detalle_ordenUncheckedUpdateManyWithoutServicioInput>
  }

  export type detalle_ordenScalarWhereInput = {
    AND?: detalle_ordenScalarWhereInput | detalle_ordenScalarWhereInput[]
    OR?: detalle_ordenScalarWhereInput[]
    NOT?: detalle_ordenScalarWhereInput | detalle_ordenScalarWhereInput[]
    id_detalle?: IntFilter<"detalle_orden"> | number
    id_orden?: IntFilter<"detalle_orden"> | number
    id_servicio?: IntFilter<"detalle_orden"> | number
    cantidad?: IntFilter<"detalle_orden"> | number
    precio_unit?: DecimalFilter<"detalle_orden"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"detalle_orden"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeNullableFilter<"detalle_orden"> | Date | string | null
  }

  export type ordenes_servicioCreateWithoutEmpleadoInput = {
    fecha_entrada?: Date | string
    fecha_salida?: Date | string | null
    observaciones?: string | null
    estado?: string
    kilometraje?: number | null
    created_at?: Date | string | null
    vehiculo: vehiculosCreateNestedOneWithoutOrdenes_servicioInput
    detalle_orden?: detalle_ordenCreateNestedManyWithoutOrdenInput
    facturas?: facturasCreateNestedManyWithoutOrdenInput
  }

  export type ordenes_servicioUncheckedCreateWithoutEmpleadoInput = {
    id_orden?: number
    id_vehiculo: number
    fecha_entrada?: Date | string
    fecha_salida?: Date | string | null
    observaciones?: string | null
    estado?: string
    kilometraje?: number | null
    created_at?: Date | string | null
    detalle_orden?: detalle_ordenUncheckedCreateNestedManyWithoutOrdenInput
    facturas?: facturasUncheckedCreateNestedManyWithoutOrdenInput
  }

  export type ordenes_servicioCreateOrConnectWithoutEmpleadoInput = {
    where: ordenes_servicioWhereUniqueInput
    create: XOR<ordenes_servicioCreateWithoutEmpleadoInput, ordenes_servicioUncheckedCreateWithoutEmpleadoInput>
  }

  export type ordenes_servicioCreateManyEmpleadoInputEnvelope = {
    data: ordenes_servicioCreateManyEmpleadoInput | ordenes_servicioCreateManyEmpleadoInput[]
    skipDuplicates?: boolean
  }

  export type ordenes_servicioUpsertWithWhereUniqueWithoutEmpleadoInput = {
    where: ordenes_servicioWhereUniqueInput
    update: XOR<ordenes_servicioUpdateWithoutEmpleadoInput, ordenes_servicioUncheckedUpdateWithoutEmpleadoInput>
    create: XOR<ordenes_servicioCreateWithoutEmpleadoInput, ordenes_servicioUncheckedCreateWithoutEmpleadoInput>
  }

  export type ordenes_servicioUpdateWithWhereUniqueWithoutEmpleadoInput = {
    where: ordenes_servicioWhereUniqueInput
    data: XOR<ordenes_servicioUpdateWithoutEmpleadoInput, ordenes_servicioUncheckedUpdateWithoutEmpleadoInput>
  }

  export type ordenes_servicioUpdateManyWithWhereWithoutEmpleadoInput = {
    where: ordenes_servicioScalarWhereInput
    data: XOR<ordenes_servicioUpdateManyMutationInput, ordenes_servicioUncheckedUpdateManyWithoutEmpleadoInput>
  }

  export type vehiculosCreateWithoutOrdenes_servicioInput = {
    marca: string
    modelo: string
    anio: number
    placas: string
    color?: string | null
    vin?: string | null
    created_at?: Date | string | null
    cliente: clientesCreateNestedOneWithoutVehiculosInput
  }

  export type vehiculosUncheckedCreateWithoutOrdenes_servicioInput = {
    id_vehiculo?: number
    id_cliente: number
    marca: string
    modelo: string
    anio: number
    placas: string
    color?: string | null
    vin?: string | null
    created_at?: Date | string | null
  }

  export type vehiculosCreateOrConnectWithoutOrdenes_servicioInput = {
    where: vehiculosWhereUniqueInput
    create: XOR<vehiculosCreateWithoutOrdenes_servicioInput, vehiculosUncheckedCreateWithoutOrdenes_servicioInput>
  }

  export type empleadosCreateWithoutOrdenes_servicioInput = {
    nombre: string
    especialidad?: string | null
    telefono?: string | null
    salario?: Decimal | DecimalJsLike | number | string | null
    activo?: boolean
    created_at?: Date | string | null
  }

  export type empleadosUncheckedCreateWithoutOrdenes_servicioInput = {
    id_empleado?: number
    nombre: string
    especialidad?: string | null
    telefono?: string | null
    salario?: Decimal | DecimalJsLike | number | string | null
    activo?: boolean
    created_at?: Date | string | null
  }

  export type empleadosCreateOrConnectWithoutOrdenes_servicioInput = {
    where: empleadosWhereUniqueInput
    create: XOR<empleadosCreateWithoutOrdenes_servicioInput, empleadosUncheckedCreateWithoutOrdenes_servicioInput>
  }

  export type detalle_ordenCreateWithoutOrdenInput = {
    cantidad?: number
    precio_unit: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    servicio: serviciosCreateNestedOneWithoutDetalle_ordenInput
  }

  export type detalle_ordenUncheckedCreateWithoutOrdenInput = {
    id_detalle?: number
    id_servicio: number
    cantidad?: number
    precio_unit: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
  }

  export type detalle_ordenCreateOrConnectWithoutOrdenInput = {
    where: detalle_ordenWhereUniqueInput
    create: XOR<detalle_ordenCreateWithoutOrdenInput, detalle_ordenUncheckedCreateWithoutOrdenInput>
  }

  export type detalle_ordenCreateManyOrdenInputEnvelope = {
    data: detalle_ordenCreateManyOrdenInput | detalle_ordenCreateManyOrdenInput[]
    skipDuplicates?: boolean
  }

  export type facturasCreateWithoutOrdenInput = {
    fecha?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    metodo_pago?: string | null
    created_at?: Date | string | null
  }

  export type facturasUncheckedCreateWithoutOrdenInput = {
    id_factura?: number
    fecha?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    metodo_pago?: string | null
    created_at?: Date | string | null
  }

  export type facturasCreateOrConnectWithoutOrdenInput = {
    where: facturasWhereUniqueInput
    create: XOR<facturasCreateWithoutOrdenInput, facturasUncheckedCreateWithoutOrdenInput>
  }

  export type facturasCreateManyOrdenInputEnvelope = {
    data: facturasCreateManyOrdenInput | facturasCreateManyOrdenInput[]
    skipDuplicates?: boolean
  }

  export type vehiculosUpsertWithoutOrdenes_servicioInput = {
    update: XOR<vehiculosUpdateWithoutOrdenes_servicioInput, vehiculosUncheckedUpdateWithoutOrdenes_servicioInput>
    create: XOR<vehiculosCreateWithoutOrdenes_servicioInput, vehiculosUncheckedCreateWithoutOrdenes_servicioInput>
    where?: vehiculosWhereInput
  }

  export type vehiculosUpdateToOneWithWhereWithoutOrdenes_servicioInput = {
    where?: vehiculosWhereInput
    data: XOR<vehiculosUpdateWithoutOrdenes_servicioInput, vehiculosUncheckedUpdateWithoutOrdenes_servicioInput>
  }

  export type vehiculosUpdateWithoutOrdenes_servicioInput = {
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    placas?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cliente?: clientesUpdateOneRequiredWithoutVehiculosNestedInput
  }

  export type vehiculosUncheckedUpdateWithoutOrdenes_servicioInput = {
    id_vehiculo?: IntFieldUpdateOperationsInput | number
    id_cliente?: IntFieldUpdateOperationsInput | number
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    placas?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type empleadosUpsertWithoutOrdenes_servicioInput = {
    update: XOR<empleadosUpdateWithoutOrdenes_servicioInput, empleadosUncheckedUpdateWithoutOrdenes_servicioInput>
    create: XOR<empleadosCreateWithoutOrdenes_servicioInput, empleadosUncheckedCreateWithoutOrdenes_servicioInput>
    where?: empleadosWhereInput
  }

  export type empleadosUpdateToOneWithWhereWithoutOrdenes_servicioInput = {
    where?: empleadosWhereInput
    data: XOR<empleadosUpdateWithoutOrdenes_servicioInput, empleadosUncheckedUpdateWithoutOrdenes_servicioInput>
  }

  export type empleadosUpdateWithoutOrdenes_servicioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    salario?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type empleadosUncheckedUpdateWithoutOrdenes_servicioInput = {
    id_empleado?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    salario?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type detalle_ordenUpsertWithWhereUniqueWithoutOrdenInput = {
    where: detalle_ordenWhereUniqueInput
    update: XOR<detalle_ordenUpdateWithoutOrdenInput, detalle_ordenUncheckedUpdateWithoutOrdenInput>
    create: XOR<detalle_ordenCreateWithoutOrdenInput, detalle_ordenUncheckedCreateWithoutOrdenInput>
  }

  export type detalle_ordenUpdateWithWhereUniqueWithoutOrdenInput = {
    where: detalle_ordenWhereUniqueInput
    data: XOR<detalle_ordenUpdateWithoutOrdenInput, detalle_ordenUncheckedUpdateWithoutOrdenInput>
  }

  export type detalle_ordenUpdateManyWithWhereWithoutOrdenInput = {
    where: detalle_ordenScalarWhereInput
    data: XOR<detalle_ordenUpdateManyMutationInput, detalle_ordenUncheckedUpdateManyWithoutOrdenInput>
  }

  export type facturasUpsertWithWhereUniqueWithoutOrdenInput = {
    where: facturasWhereUniqueInput
    update: XOR<facturasUpdateWithoutOrdenInput, facturasUncheckedUpdateWithoutOrdenInput>
    create: XOR<facturasCreateWithoutOrdenInput, facturasUncheckedCreateWithoutOrdenInput>
  }

  export type facturasUpdateWithWhereUniqueWithoutOrdenInput = {
    where: facturasWhereUniqueInput
    data: XOR<facturasUpdateWithoutOrdenInput, facturasUncheckedUpdateWithoutOrdenInput>
  }

  export type facturasUpdateManyWithWhereWithoutOrdenInput = {
    where: facturasScalarWhereInput
    data: XOR<facturasUpdateManyMutationInput, facturasUncheckedUpdateManyWithoutOrdenInput>
  }

  export type facturasScalarWhereInput = {
    AND?: facturasScalarWhereInput | facturasScalarWhereInput[]
    OR?: facturasScalarWhereInput[]
    NOT?: facturasScalarWhereInput | facturasScalarWhereInput[]
    id_factura?: IntFilter<"facturas"> | number
    id_orden?: IntFilter<"facturas"> | number
    fecha?: DateTimeFilter<"facturas"> | Date | string
    subtotal?: DecimalFilter<"facturas"> | Decimal | DecimalJsLike | number | string
    iva?: DecimalFilter<"facturas"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"facturas"> | Decimal | DecimalJsLike | number | string
    metodo_pago?: StringNullableFilter<"facturas"> | string | null
    created_at?: DateTimeNullableFilter<"facturas"> | Date | string | null
  }

  export type ordenes_servicioCreateWithoutDetalle_ordenInput = {
    fecha_entrada?: Date | string
    fecha_salida?: Date | string | null
    observaciones?: string | null
    estado?: string
    kilometraje?: number | null
    created_at?: Date | string | null
    vehiculo: vehiculosCreateNestedOneWithoutOrdenes_servicioInput
    empleado?: empleadosCreateNestedOneWithoutOrdenes_servicioInput
    facturas?: facturasCreateNestedManyWithoutOrdenInput
  }

  export type ordenes_servicioUncheckedCreateWithoutDetalle_ordenInput = {
    id_orden?: number
    id_vehiculo: number
    id_empleado?: number | null
    fecha_entrada?: Date | string
    fecha_salida?: Date | string | null
    observaciones?: string | null
    estado?: string
    kilometraje?: number | null
    created_at?: Date | string | null
    facturas?: facturasUncheckedCreateNestedManyWithoutOrdenInput
  }

  export type ordenes_servicioCreateOrConnectWithoutDetalle_ordenInput = {
    where: ordenes_servicioWhereUniqueInput
    create: XOR<ordenes_servicioCreateWithoutDetalle_ordenInput, ordenes_servicioUncheckedCreateWithoutDetalle_ordenInput>
  }

  export type serviciosCreateWithoutDetalle_ordenInput = {
    nombre: string
    descripcion?: string | null
    precio: Decimal | DecimalJsLike | number | string
    tiempo_est?: number | null
    activo?: boolean
    created_at?: Date | string | null
  }

  export type serviciosUncheckedCreateWithoutDetalle_ordenInput = {
    id_servicio?: number
    nombre: string
    descripcion?: string | null
    precio: Decimal | DecimalJsLike | number | string
    tiempo_est?: number | null
    activo?: boolean
    created_at?: Date | string | null
  }

  export type serviciosCreateOrConnectWithoutDetalle_ordenInput = {
    where: serviciosWhereUniqueInput
    create: XOR<serviciosCreateWithoutDetalle_ordenInput, serviciosUncheckedCreateWithoutDetalle_ordenInput>
  }

  export type ordenes_servicioUpsertWithoutDetalle_ordenInput = {
    update: XOR<ordenes_servicioUpdateWithoutDetalle_ordenInput, ordenes_servicioUncheckedUpdateWithoutDetalle_ordenInput>
    create: XOR<ordenes_servicioCreateWithoutDetalle_ordenInput, ordenes_servicioUncheckedCreateWithoutDetalle_ordenInput>
    where?: ordenes_servicioWhereInput
  }

  export type ordenes_servicioUpdateToOneWithWhereWithoutDetalle_ordenInput = {
    where?: ordenes_servicioWhereInput
    data: XOR<ordenes_servicioUpdateWithoutDetalle_ordenInput, ordenes_servicioUncheckedUpdateWithoutDetalle_ordenInput>
  }

  export type ordenes_servicioUpdateWithoutDetalle_ordenInput = {
    fecha_entrada?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    kilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehiculo?: vehiculosUpdateOneRequiredWithoutOrdenes_servicioNestedInput
    empleado?: empleadosUpdateOneWithoutOrdenes_servicioNestedInput
    facturas?: facturasUpdateManyWithoutOrdenNestedInput
  }

  export type ordenes_servicioUncheckedUpdateWithoutDetalle_ordenInput = {
    id_orden?: IntFieldUpdateOperationsInput | number
    id_vehiculo?: IntFieldUpdateOperationsInput | number
    id_empleado?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_entrada?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    kilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facturas?: facturasUncheckedUpdateManyWithoutOrdenNestedInput
  }

  export type serviciosUpsertWithoutDetalle_ordenInput = {
    update: XOR<serviciosUpdateWithoutDetalle_ordenInput, serviciosUncheckedUpdateWithoutDetalle_ordenInput>
    create: XOR<serviciosCreateWithoutDetalle_ordenInput, serviciosUncheckedCreateWithoutDetalle_ordenInput>
    where?: serviciosWhereInput
  }

  export type serviciosUpdateToOneWithWhereWithoutDetalle_ordenInput = {
    where?: serviciosWhereInput
    data: XOR<serviciosUpdateWithoutDetalle_ordenInput, serviciosUncheckedUpdateWithoutDetalle_ordenInput>
  }

  export type serviciosUpdateWithoutDetalle_ordenInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tiempo_est?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviciosUncheckedUpdateWithoutDetalle_ordenInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tiempo_est?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ordenes_servicioCreateWithoutFacturasInput = {
    fecha_entrada?: Date | string
    fecha_salida?: Date | string | null
    observaciones?: string | null
    estado?: string
    kilometraje?: number | null
    created_at?: Date | string | null
    vehiculo: vehiculosCreateNestedOneWithoutOrdenes_servicioInput
    empleado?: empleadosCreateNestedOneWithoutOrdenes_servicioInput
    detalle_orden?: detalle_ordenCreateNestedManyWithoutOrdenInput
  }

  export type ordenes_servicioUncheckedCreateWithoutFacturasInput = {
    id_orden?: number
    id_vehiculo: number
    id_empleado?: number | null
    fecha_entrada?: Date | string
    fecha_salida?: Date | string | null
    observaciones?: string | null
    estado?: string
    kilometraje?: number | null
    created_at?: Date | string | null
    detalle_orden?: detalle_ordenUncheckedCreateNestedManyWithoutOrdenInput
  }

  export type ordenes_servicioCreateOrConnectWithoutFacturasInput = {
    where: ordenes_servicioWhereUniqueInput
    create: XOR<ordenes_servicioCreateWithoutFacturasInput, ordenes_servicioUncheckedCreateWithoutFacturasInput>
  }

  export type ordenes_servicioUpsertWithoutFacturasInput = {
    update: XOR<ordenes_servicioUpdateWithoutFacturasInput, ordenes_servicioUncheckedUpdateWithoutFacturasInput>
    create: XOR<ordenes_servicioCreateWithoutFacturasInput, ordenes_servicioUncheckedCreateWithoutFacturasInput>
    where?: ordenes_servicioWhereInput
  }

  export type ordenes_servicioUpdateToOneWithWhereWithoutFacturasInput = {
    where?: ordenes_servicioWhereInput
    data: XOR<ordenes_servicioUpdateWithoutFacturasInput, ordenes_servicioUncheckedUpdateWithoutFacturasInput>
  }

  export type ordenes_servicioUpdateWithoutFacturasInput = {
    fecha_entrada?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    kilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehiculo?: vehiculosUpdateOneRequiredWithoutOrdenes_servicioNestedInput
    empleado?: empleadosUpdateOneWithoutOrdenes_servicioNestedInput
    detalle_orden?: detalle_ordenUpdateManyWithoutOrdenNestedInput
  }

  export type ordenes_servicioUncheckedUpdateWithoutFacturasInput = {
    id_orden?: IntFieldUpdateOperationsInput | number
    id_vehiculo?: IntFieldUpdateOperationsInput | number
    id_empleado?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_entrada?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    kilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detalle_orden?: detalle_ordenUncheckedUpdateManyWithoutOrdenNestedInput
  }

  export type vehiculosCreateManyClienteInput = {
    id_vehiculo?: number
    marca: string
    modelo: string
    anio: number
    placas: string
    color?: string | null
    vin?: string | null
    created_at?: Date | string | null
  }

  export type vehiculosUpdateWithoutClienteInput = {
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    placas?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ordenes_servicio?: ordenes_servicioUpdateManyWithoutVehiculoNestedInput
  }

  export type vehiculosUncheckedUpdateWithoutClienteInput = {
    id_vehiculo?: IntFieldUpdateOperationsInput | number
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    placas?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ordenes_servicio?: ordenes_servicioUncheckedUpdateManyWithoutVehiculoNestedInput
  }

  export type vehiculosUncheckedUpdateManyWithoutClienteInput = {
    id_vehiculo?: IntFieldUpdateOperationsInput | number
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    placas?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ordenes_servicioCreateManyVehiculoInput = {
    id_orden?: number
    id_empleado?: number | null
    fecha_entrada?: Date | string
    fecha_salida?: Date | string | null
    observaciones?: string | null
    estado?: string
    kilometraje?: number | null
    created_at?: Date | string | null
  }

  export type ordenes_servicioUpdateWithoutVehiculoInput = {
    fecha_entrada?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    kilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empleado?: empleadosUpdateOneWithoutOrdenes_servicioNestedInput
    detalle_orden?: detalle_ordenUpdateManyWithoutOrdenNestedInput
    facturas?: facturasUpdateManyWithoutOrdenNestedInput
  }

  export type ordenes_servicioUncheckedUpdateWithoutVehiculoInput = {
    id_orden?: IntFieldUpdateOperationsInput | number
    id_empleado?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_entrada?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    kilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detalle_orden?: detalle_ordenUncheckedUpdateManyWithoutOrdenNestedInput
    facturas?: facturasUncheckedUpdateManyWithoutOrdenNestedInput
  }

  export type ordenes_servicioUncheckedUpdateManyWithoutVehiculoInput = {
    id_orden?: IntFieldUpdateOperationsInput | number
    id_empleado?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_entrada?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    kilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type detalle_ordenCreateManyServicioInput = {
    id_detalle?: number
    id_orden: number
    cantidad?: number
    precio_unit: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
  }

  export type detalle_ordenUpdateWithoutServicioInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orden?: ordenes_servicioUpdateOneRequiredWithoutDetalle_ordenNestedInput
  }

  export type detalle_ordenUncheckedUpdateWithoutServicioInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_orden?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type detalle_ordenUncheckedUpdateManyWithoutServicioInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_orden?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ordenes_servicioCreateManyEmpleadoInput = {
    id_orden?: number
    id_vehiculo: number
    fecha_entrada?: Date | string
    fecha_salida?: Date | string | null
    observaciones?: string | null
    estado?: string
    kilometraje?: number | null
    created_at?: Date | string | null
  }

  export type ordenes_servicioUpdateWithoutEmpleadoInput = {
    fecha_entrada?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    kilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehiculo?: vehiculosUpdateOneRequiredWithoutOrdenes_servicioNestedInput
    detalle_orden?: detalle_ordenUpdateManyWithoutOrdenNestedInput
    facturas?: facturasUpdateManyWithoutOrdenNestedInput
  }

  export type ordenes_servicioUncheckedUpdateWithoutEmpleadoInput = {
    id_orden?: IntFieldUpdateOperationsInput | number
    id_vehiculo?: IntFieldUpdateOperationsInput | number
    fecha_entrada?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    kilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detalle_orden?: detalle_ordenUncheckedUpdateManyWithoutOrdenNestedInput
    facturas?: facturasUncheckedUpdateManyWithoutOrdenNestedInput
  }

  export type ordenes_servicioUncheckedUpdateManyWithoutEmpleadoInput = {
    id_orden?: IntFieldUpdateOperationsInput | number
    id_vehiculo?: IntFieldUpdateOperationsInput | number
    fecha_entrada?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    kilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type detalle_ordenCreateManyOrdenInput = {
    id_detalle?: number
    id_servicio: number
    cantidad?: number
    precio_unit: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
  }

  export type facturasCreateManyOrdenInput = {
    id_factura?: number
    fecha?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    metodo_pago?: string | null
    created_at?: Date | string | null
  }

  export type detalle_ordenUpdateWithoutOrdenInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    servicio?: serviciosUpdateOneRequiredWithoutDetalle_ordenNestedInput
  }

  export type detalle_ordenUncheckedUpdateWithoutOrdenInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_servicio?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type detalle_ordenUncheckedUpdateManyWithoutOrdenInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_servicio?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type facturasUpdateWithoutOrdenInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metodo_pago?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type facturasUncheckedUpdateWithoutOrdenInput = {
    id_factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metodo_pago?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type facturasUncheckedUpdateManyWithoutOrdenInput = {
    id_factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metodo_pago?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ClientesCountOutputTypeDefaultArgs instead
     */
    export type ClientesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehiculosCountOutputTypeDefaultArgs instead
     */
    export type VehiculosCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehiculosCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiciosCountOutputTypeDefaultArgs instead
     */
    export type ServiciosCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiciosCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmpleadosCountOutputTypeDefaultArgs instead
     */
    export type EmpleadosCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpleadosCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Ordenes_servicioCountOutputTypeDefaultArgs instead
     */
    export type Ordenes_servicioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Ordenes_servicioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use clientesDefaultArgs instead
     */
    export type clientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = clientesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use vehiculosDefaultArgs instead
     */
    export type vehiculosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = vehiculosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use serviciosDefaultArgs instead
     */
    export type serviciosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = serviciosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use empleadosDefaultArgs instead
     */
    export type empleadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = empleadosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ordenes_servicioDefaultArgs instead
     */
    export type ordenes_servicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ordenes_servicioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use detalle_ordenDefaultArgs instead
     */
    export type detalle_ordenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = detalle_ordenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use facturasDefaultArgs instead
     */
    export type facturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = facturasDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}